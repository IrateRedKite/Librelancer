// <auto-generated/>
// ReSharper disable InconsistentNaming
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference
using System;
using System.Runtime.InteropServices;
namespace ImGuiNET;

/// <summary>
/// <para>Typically, 1 command = 1 GPU draw call (unless command is a callback)</para>
/// <para>- VtxOffset: When 'io.BackendFlags &amp; ImGuiBackendFlags_RendererHasVtxOffset' is enabled,</para>
/// <para>this fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.</para>
/// <para>Backends made for &lt;1.71. will typically ignore the VtxOffset fields.</para>
/// - The ClipRect/TexRef/VtxOffset fields must be contiguous as we memcmp() them together (this is asserted for).
/// </summary>
public unsafe partial struct ImDrawCmd
{
    /// <summary>
    /// 4*4  // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData-&gt;DisplayPos to get clipping rectangle in "viewport" coordinates
    /// </summary>
    public System.Numerics.Vector4 ClipRect;
    /// <summary>
    /// 16   // Reference to a font/texture atlas (where backend called ImTextureData::SetTexID()) or to a user-provided texture ID (via e.g. ImGui::Image() calls). Both will lead to a ImTextureID value.
    /// </summary>
    public ImTextureRef TexRef;
    /// <summary>
    /// 4    // Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be &gt;0 to support meshes larger than 64K vertices with 16-bit indices.
    /// </summary>
    public uint VtxOffset;
    /// <summary>
    /// 4    // Start offset in index buffer.
    /// </summary>
    public uint IdxOffset;
    /// <summary>
    /// 4    // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
    /// </summary>
    public uint ElemCount;
    /// <summary>
    /// 4-8  // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
    /// </summary>
    public delegate* unmanaged<ImDrawList*, ImDrawCmd*, void> UserCallback;
    /// <summary>
    /// 4-8  // Callback user data (when UserCallback != NULL). If called AddCallback() with size == 0, this is a copy of the AddCallback() argument. If called AddCallback() with size &gt; 0, this is pointing to a buffer where data is stored.
    /// </summary>
    public IntPtr UserCallbackData;
    /// <summary>
    /// 4 // Size of callback user data when using storage, otherwise 0.
    /// </summary>
    public int UserCallbackDataSize;
    /// <summary>
    /// 4 // [Internal] Offset of callback user data when using storage, otherwise -1.
    /// </summary>
    public int UserCallbackDataOffset;
}
