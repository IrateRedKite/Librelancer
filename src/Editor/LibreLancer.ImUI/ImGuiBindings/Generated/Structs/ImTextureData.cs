// <auto-generated/>
// ReSharper disable InconsistentNaming
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference
using System;
using System.Runtime.InteropServices;
namespace ImGuiNET;

/// <summary>
/// <para>Specs and pixel storage for a texture used by Dear ImGui.</para>
/// <para>This is only useful for (1) core library and (2) backends. End-user/applications do not need to care about this.</para>
/// <para>Renderer Backends will create a GPU-side version of this.</para>
/// <para>Why does we store two identifiers: TexID and BackendUserData?</para>
/// <para>- ImTextureID    TexID           = lower-level identifier stored in ImDrawCmd. ImDrawCmd can refer to textures not created by the backend, and for which there's no ImTextureData.</para>
/// <para>- void*          BackendUserData = higher-level opaque storage for backend own book-keeping. Some backends may have enough with TexID and not need both.</para>
/// In columns below: who reads/writes each fields? 'r'=read, 'w'=write, 'core'=main library, 'backend'=renderer backend
/// </summary>
public unsafe partial struct ImTextureData
{
    /// <summary>
    /// <para>------------------------------------------ core / backend ---------------------------------------</para>
    /// w    -   // Sequential index to facilitate identifying a texture when debugging/printing. Unique per atlas.
    /// </summary>
    public int UniqueID;
    /// <summary>
    /// rw   rw  // ImTextureStatus_OK/_WantCreate/_WantUpdates/_WantDestroy. Always use SetStatus() to modify!
    /// </summary>
    public ImTextureStatus Status;
    /// <summary>
    /// -    rw  // Convenience storage for backend. Some backends may have enough with TexID.
    /// </summary>
    public IntPtr BackendUserData;
    /// <summary>
    /// r    w   // Backend-specific texture identifier. Always use SetTexID() to modify! The identifier will stored in ImDrawCmd::GetTexID() and passed to backend's RenderDrawData function.
    /// </summary>
    public ulong TexID;
    /// <summary>
    /// w    r   // ImTextureFormat_RGBA32 (default) or ImTextureFormat_Alpha8
    /// </summary>
    public ImTextureFormat Format;
    /// <summary>
    /// w    r   // Texture width
    /// </summary>
    public int Width;
    /// <summary>
    /// w    r   // Texture height
    /// </summary>
    public int Height;
    /// <summary>
    /// w    r   // 4 or 1
    /// </summary>
    public int BytesPerPixel;
    /// <summary>
    /// w    r   // Pointer to buffer holding 'Width*Height' pixels and 'Width*Height*BytesPerPixels' bytes.
    /// </summary>
    public byte* Pixels;
    /// <summary>
    /// w    r   // Bounding box encompassing all past and queued Updates[].
    /// </summary>
    public ImTextureRect UsedRect;
    /// <summary>
    /// w    r   // Bounding box encompassing all queued Updates[].
    /// </summary>
    public ImTextureRect UpdateRect;
    /// <summary>
    /// w    r   // Array of individual updates.
    /// </summary>
    public ImVector<ImTextureRect> Updates;
    /// <summary>
    /// w    r   // In order to facilitate handling Status==WantDestroy in some backend: this is a count successive frames where the texture was not used. Always &gt;0 when Status==WantDestroy.
    /// </summary>
    public int UnusedFrames;
    /// <summary>
    /// w    r   // Number of contexts using this texture. Used during backend shutdown.
    /// </summary>
    public ushort RefCount;
    private byte __UseColors;
    /// <summary>
    /// w    r   // Tell whether our texture data is known to use colors (rather than just white + alpha).
    /// </summary>
    public bool UseColors
    {
        get => __UseColors != 0;
        set => __UseColors = value ? (byte)1 : (byte)0;
    }
    private byte __WantDestroyNextFrame;
    /// <summary>
    /// rw   -   // [Internal] Queued to set ImTextureStatus_WantDestroy next frame. May still be used in the current frame.
    /// </summary>
    public bool WantDestroyNextFrame
    {
        get => __WantDestroyNextFrame != 0;
        set => __WantDestroyNextFrame = value ? (byte)1 : (byte)0;
    }
}
