// <auto-generated/>
// ReSharper disable InconsistentNaming
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference
using System;
using System.Runtime.InteropServices;
namespace ImGuiNET;

/// <summary>
/// A font input/source (we may rename this to ImFontSource in the future)
/// </summary>
public unsafe partial struct ImFontConfig
{
    [System.Runtime.CompilerServices.InlineArray(40)]
    private struct __inline_Name
    {
        public sbyte _0;
    }
    private __inline_Name __array_Name;
    /// <summary>
    /// <para>Data Source</para>
    /// &lt;auto&gt;   // Name (strictly to ease debugging, hence limited size buffer)
    /// </summary>
    public Span<sbyte> Name => __array_Name;

    /// <summary>
    /// // TTF/OTF data
    /// </summary>
    public IntPtr FontData;
    /// <summary>
    /// // TTF/OTF data size
    /// </summary>
    public int FontDataSize;
    private byte __FontDataOwnedByAtlas;
    /// <summary>
    /// true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
    /// </summary>
    public bool FontDataOwnedByAtlas
    {
        get => __FontDataOwnedByAtlas != 0;
        set => __FontDataOwnedByAtlas = value ? (byte)1 : (byte)0;
    }
    private byte __MergeMode;
    /// <summary>
    /// <para>Options</para>
    /// false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
    /// </summary>
    public bool MergeMode
    {
        get => __MergeMode != 0;
        set => __MergeMode = value ? (byte)1 : (byte)0;
    }
    private byte __PixelSnapH;
    /// <summary>
    /// false    // Align every glyph AdvanceX to pixel boundaries. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
    /// </summary>
    public bool PixelSnapH
    {
        get => __PixelSnapH != 0;
        set => __PixelSnapH = value ? (byte)1 : (byte)0;
    }
    private byte __PixelSnapV;
    /// <summary>
    /// true     // Align Scaled GlyphOffset.y to pixel boundaries.
    /// </summary>
    public bool PixelSnapV
    {
        get => __PixelSnapV != 0;
        set => __PixelSnapV = value ? (byte)1 : (byte)0;
    }
    /// <summary>
    /// 0 (2)    // Rasterize at higher quality for sub-pixel positioning. 0 == auto == 1 or 2 depending on size. Note the difference between 2 and 3 is minimal. You can reduce this to 1 for large glyphs save memory. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.
    /// </summary>
    public sbyte OversampleH;
    /// <summary>
    /// 0 (1)    // Rasterize at higher quality for sub-pixel positioning. 0 == auto == 1. This is not really useful as we don't use sub-pixel positions on the Y axis.
    /// </summary>
    public sbyte OversampleV;
    /// <summary>
    /// 0        // Explicitly specify Unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.
    /// </summary>
    public ushort EllipsisChar;
    /// <summary>
    /// // Size in pixels for rasterizer (more or less maps to the resulting font height).
    /// </summary>
    public float SizePixels;
    /// <summary>
    /// NULL     // *LEGACY* THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE. Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list).
    /// </summary>
    public ushort* GlyphRanges;
    /// <summary>
    /// NULL     // Pointer to a small user-provided list of Unicode ranges (2 value per range, values are inclusive, zero-terminated list). This is very close to GlyphRanges[] but designed to exclude ranges from a font source, when merging fonts with overlapping glyphs. Use "Input Glyphs Overlap Detection Tool" to find about your overlapping ranges.
    /// </summary>
    public ushort* GlyphExcludeRanges;
    /// <summary>
    /// <para>ImVec2        GlyphExtraSpacing;      // 0, 0     // (REMOVED AT IT SEEMS LARGELY OBSOLETE. PLEASE REPORT IF YOU WERE USING THIS). Extra spacing (in pixels) between glyphs when rendered: essentially add to glyph-&gt;AdvanceX. Only X axis is supported for now.</para>
    /// 0, 0     // Offset (in pixels) all glyphs from this font input. Absolute value for default size, other sizes will scale this value.
    /// </summary>
    public System.Numerics.Vector2 GlyphOffset;
    /// <summary>
    /// 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font. Absolute value for default size, other sizes will scale this value.
    /// </summary>
    public float GlyphMinAdvanceX;
    /// <summary>
    /// FLT_MAX  // Maximum AdvanceX for glyphs
    /// </summary>
    public float GlyphMaxAdvanceX;
    /// <summary>
    /// 0        // Extra spacing (in pixels) between glyphs. Please contact us if you are using this. // FIXME-NEWATLAS: Intentionally unscaled
    /// </summary>
    public float GlyphExtraAdvanceX;
    /// <summary>
    /// 0        // Index of font within TTF/OTF file
    /// </summary>
    public uint FontNo;
    /// <summary>
    /// 0        // Settings for custom font builder. THIS IS BUILDER IMPLEMENTATION DEPENDENT. Leave as zero if unsure.
    /// </summary>
    public uint FontLoaderFlags;
    /// <summary>
    /// <para>unsigned int  FontBuilderFlags;       // --       // [Renamed in 1.92] Ue FontLoaderFlags.</para>
    /// 1.0f     // Linearly brighten (&gt;1.0f) or darken (&lt;1.0f) font output. Brightening small fonts may be a good workaround to make them more readable. This is a silly thing we may remove in the future.
    /// </summary>
    public float RasterizerMultiply;
    /// <summary>
    /// 1.0f     // [LEGACY: this only makes sense when ImGuiBackendFlags_RendererHasTextures is not supported] DPI scale multiplier for rasterization. Not altering other font metrics: makes it easy to swap between e.g. a 100% and a 400% fonts for a zooming display, or handle Retina screen. IMPORTANT: If you change this it is expected that you increase/decrease font scale roughly to the inverse of this, otherwise quality may look lowered.
    /// </summary>
    public float RasterizerDensity;
    /// <summary>
    /// <para>[Internal]</para>
    /// Font flags (don't use just yet, will be exposed in upcoming 1.92.X updates)
    /// </summary>
    public ImFontFlags Flags;
    private ImFont* __DstFont;
    /// <summary>
    /// Target font (as we merging fonts, multiple ImFontConfig may target the same font)
    /// </summary>
    public ImFontPtr DstFont
    {
        get => ImFontPtr.Create(__DstFont);
        set => __DstFont = ImFontPtr.GetHandle(value);
    }
    private IntPtr __FontLoader;
    /// <summary>
    /// Custom font backend for this source (default source is the one stored in ImFontAtlas)
    /// </summary>
    public ImFontLoaderPtr FontLoader
    {
        get => ImFontLoaderPtr.Create(__FontLoader);
        set => __FontLoader = ImFontLoaderPtr.GetHandle(value);
    }
    /// <summary>
    /// Font loader opaque storage (per font config)
    /// </summary>
    public IntPtr FontLoaderData;
}
