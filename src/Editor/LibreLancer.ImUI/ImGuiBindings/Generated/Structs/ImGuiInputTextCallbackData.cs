// <auto-generated/>
// ReSharper disable InconsistentNaming
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference
using System;
using System.Runtime.InteropServices;
namespace ImGuiNET;

/// <summary>
/// <para>Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.</para>
/// <para>The callback function should return 0 by default.</para>
/// <para>Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)</para>
/// <para>- ImGuiInputTextFlags_CallbackEdit:        Callback on buffer edit. Note that InputText() already returns true on edit + you can always use IsItemEdited(). The callback is useful to manipulate the underlying buffer while focus is active.</para>
/// <para>- ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration</para>
/// <para>- ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB</para>
/// <para>- ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows</para>
/// <para>- ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.</para>
/// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.
/// </summary>
public unsafe partial struct ImGuiInputTextCallbackData
{
    private IntPtr __Ctx;
    /// <summary>
    /// Parent UI context
    /// </summary>
    public ImGuiContextPtr Ctx
    {
        get => ImGuiContextPtr.Create(__Ctx);
        set => __Ctx = ImGuiContextPtr.GetHandle(value);
    }
    /// <summary>
    /// One ImGuiInputTextFlags_Callback*    // Read-only
    /// </summary>
    public ImGuiInputTextFlags EventFlag;
    /// <summary>
    /// What user passed to InputText()      // Read-only
    /// </summary>
    public ImGuiInputTextFlags Flags;
    /// <summary>
    /// What user passed to InputText()      // Read-only
    /// </summary>
    public IntPtr UserData;
    /// <summary>
    /// <para>Arguments for the different callback events</para>
    /// <para>- During Resize callback, Buf will be same as your input buffer.</para>
    /// <para>- However, during Completion/History/Always callback, Buf always points to our own internal data (it is not the same as your buffer)! Changes to it will be reflected into your own buffer shortly after the callback.</para>
    /// <para>- To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.</para>
    /// <para>- If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 &lt;= BufTextLen &lt; BufSize) and set 'BufDirty'' to true so InputText can update its internal state.</para>
    /// Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;
    /// </summary>
    public ushort EventChar;
    /// <summary>
    /// Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]
    /// </summary>
    public ImGuiKey EventKey;
    /// <summary>
    /// Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!
    /// </summary>
    public IntPtr Buf;
    /// <summary>
    /// Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()
    /// </summary>
    public int BufTextLen;
    /// <summary>
    /// Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1
    /// </summary>
    public int BufSize;
    private byte __BufDirty;
    /// <summary>
    /// Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]
    /// </summary>
    public bool BufDirty
    {
        get => __BufDirty != 0;
        set => __BufDirty = value ? (byte)1 : (byte)0;
    }
    /// <summary>
    /// // Read-write   // [Completion,History,Always]
    /// </summary>
    public int CursorPos;
    /// <summary>
    /// // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)
    /// </summary>
    public int SelectionStart;
    /// <summary>
    /// // Read-write   // [Completion,History,Always]
    /// </summary>
    public int SelectionEnd;
}
