// <auto-generated/>
// ReSharper disable InconsistentNaming
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference
using System;
using System.Runtime.InteropServices;
namespace ImGuiNET;

/// <summary>
/// <para>Font runtime data and rendering</para>
/// <para>- ImFontAtlas automatically loads a default embedded font for you if you didn't load one manually.</para>
/// <para>- Since 1.92.X a font may be rendered as any size! Therefore a font doesn't have one specific size.</para>
/// <para>- Use 'font-&gt;GetFontBaked(size)' to retrieve the ImFontBaked* corresponding to a given size.</para>
/// - If you used g.Font + g.FontSize (which is frequent from the ImGui layer), you can use g.FontBaked as a shortcut, as g.FontBaked == g.Font-&gt;GetFontBaked(g.FontSize).
/// </summary>
public unsafe partial struct ImFont
{
    private ImFontBaked* __LastBaked;
    /// <summary>
    /// <para>[Internal] Members: Hot ~12-20 bytes</para>
    /// 4-8   // Cache last bound baked. NEVER USE DIRECTLY. Use GetFontBaked().
    /// </summary>
    public ImFontBakedPtr LastBaked
    {
        get => ImFontBakedPtr.Create(__LastBaked);
        set => __LastBaked = ImFontBakedPtr.GetHandle(value);
    }
    private ImFontAtlas* __ContainerAtlas;
    /// <summary>
    /// 4-8   // What we have been loaded into.
    /// </summary>
    public ImFontAtlasPtr ContainerAtlas
    {
        get => ImFontAtlasPtr.Create(__ContainerAtlas);
        set => __ContainerAtlas = ImFontAtlasPtr.GetHandle(value);
    }
    /// <summary>
    /// 4     // Font flags.
    /// </summary>
    public ImFontFlags Flags;
    /// <summary>
    /// Current rasterizer density. This is a varying state of the font.
    /// </summary>
    public float CurrentRasterizerDensity;
    /// <summary>
    /// <para>[Internal] Members: Cold ~24-52 bytes</para>
    /// <para>Conceptually Sources[] is the list of font sources merged to create this font.</para>
    /// Unique identifier for the font
    /// </summary>
    public uint FontId;
    /// <summary>
    /// 4     // in  // Font size passed to AddFont(). Use for old code calling PushFont() expecting to use that size. (use ImGui::GetFontBaked() to get font baked at current bound size).
    /// </summary>
    public float LegacySize;
    /// <summary>
    /// 16    // in  // List of sources. Pointers within ContainerAtlas-&gt;Sources[]
    /// </summary>
    public ImPtrVector<ImFontConfig> Sources;
    /// <summary>
    /// 2-4   // out // Character used for ellipsis rendering ('...').
    /// </summary>
    public ushort EllipsisChar;
    /// <summary>
    /// 2-4   // out // Character used if a glyph isn't found (U+FFFD, '?')
    /// </summary>
    public ushort FallbackChar;
    [System.Runtime.CompilerServices.InlineArray((0xFFFF +1)/8192/8)]
    private struct __inline_Used8kPagesMap
    {
        public byte _0;
    }
    private __inline_Used8kPagesMap __array_Used8kPagesMap;
    /// <summary>
    /// 1 bytes if ImWchar=ImWchar16, 16 bytes if ImWchar==ImWchar32. Store 1-bit for each block of 4K codepoints that has one active glyph. This is mainly used to facilitate iterations across all used codepoints.
    /// </summary>
    public Span<byte> Used8kPagesMap => __array_Used8kPagesMap;

    private byte __EllipsisAutoBake;
    /// <summary>
    /// 1     //     // Mark when the "..." glyph needs to be generated.
    /// </summary>
    public bool EllipsisAutoBake
    {
        get => __EllipsisAutoBake != 0;
        set => __EllipsisAutoBake = value ? (byte)1 : (byte)0;
    }
    /// <summary>
    /// 16    //     // Remapping pairs when using AddRemapChar(), otherwise empty.
    /// </summary>
    public ImGuiStorage RemapPairs;
}
