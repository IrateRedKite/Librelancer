// <auto-generated/>
// ReSharper disable InconsistentNaming
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference
using System;
using System.Runtime.InteropServices;
namespace ImGuiNET;

/// <summary>
/// <para>Optional helper to store multi-selection state + apply multi-selection requests.</para>
/// <para>- Used by our demos and provided as a convenience to easily implement basic multi-selection.</para>
/// <para>- Iterate selection with 'void* it = NULL; ImGuiID id; while (selection.GetNextSelectedItem(&amp;it, &amp;id)) { ... }'</para>
/// <para>Or you can check 'if (Contains(id)) { ... }' for each possible object if their number is not too high to iterate.</para>
/// <para>- USING THIS IS NOT MANDATORY. This is only a helper and not a required API.</para>
/// <para>To store a multi-selection, in your application you could:</para>
/// <para>- Use this helper as a convenience. We use our simple key-&gt;value ImGuiStorage as a std::set&lt;ImGuiID&gt; replacement.</para>
/// <para>- Use your own external storage: e.g. std::set&lt;MyObjectId&gt;, std::vector&lt;MyObjectId&gt;, interval trees, intrusively stored selection etc.</para>
/// <para>In ImGuiSelectionBasicStorage we:</para>
/// <para>- always use indices in the multi-selection API (passed to SetNextItemSelectionUserData(), retrieved in ImGuiMultiSelectIO)</para>
/// <para>- use the AdapterIndexToStorageId() indirection layer to abstract how persistent selection data is derived from an index.</para>
/// <para>- use decently optimized logic to allow queries and insertion of very large selection sets.</para>
/// <para>- do not preserve selection order.</para>
/// <para>Many combinations are possible depending on how you prefer to store your items and how you prefer to store your selection.</para>
/// <para>Large applications are likely to eventually want to get rid of this indirection layer and do their own thing.</para>
/// See https://github.com/ocornut/imgui/wiki/Multi-Select for details and pseudo-code using this helper.
/// </summary>
public unsafe partial struct ImGuiSelectionBasicStorage
{
    /// <summary>
    /// <para>Members</para>
    /// // Number of selected items, maintained by this helper.
    /// </summary>
    public int Size;
    private byte __PreserveOrder;
    /// <summary>
    /// = false  // GetNextSelectedItem() will return ordered selection (currently implemented by two additional sorts of selection. Could be improved)
    /// </summary>
    public bool PreserveOrder
    {
        get => __PreserveOrder != 0;
        set => __PreserveOrder = value ? (byte)1 : (byte)0;
    }
    /// <summary>
    /// = NULL   // User data for use by adapter function        // e.g. selection.UserData = (void*)my_items;
    /// </summary>
    public IntPtr UserData;
    /// <summary>
    /// e.g. selection.AdapterIndexToStorageId = [](ImGuiSelectionBasicStorage* self, int idx) { return ((MyItems**)self-&gt;UserData)[idx]-&gt;ID; };
    /// </summary>
    public delegate* unmanaged<ImGuiSelectionBasicStorage*, int, uint> AdapterIndexToStorageId;
    /// <summary>
    /// [Internal] Increasing counter to store selection order
    /// </summary>
    public int _SelectionOrder;
    /// <summary>
    /// [Internal] Selection set. Think of this as similar to e.g. std::set&lt;ImGuiID&gt;. Prefer not accessing directly: iterate with GetNextSelectedItem().
    /// </summary>
    public ImGuiStorage _Storage;
}
