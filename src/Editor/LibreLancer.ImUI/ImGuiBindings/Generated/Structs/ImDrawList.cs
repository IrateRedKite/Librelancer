// <auto-generated/>
// ReSharper disable InconsistentNaming
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference
using System;
using System.Runtime.InteropServices;
namespace ImGuiNET;

/// <summary>
/// <para>Draw command list</para>
/// <para>This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame,</para>
/// <para>all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.</para>
/// <para>Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to</para>
/// <para>access the current window draw list and draw custom primitives.</para>
/// <para>You can interleave normal ImGui:: calls and adding primitives to the current draw list.</para>
/// <para>In single viewport mode, top-left is == GetMainViewport()-&gt;Pos (generally 0,0), bottom-right is == GetMainViewport()-&gt;Pos+Size (generally io.DisplaySize).</para>
/// <para>You are totally free to apply whatever transformation matrix you want to the data (depending on the use of the transformation you may want to apply it to ClipRect as well!)</para>
/// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.
/// </summary>
public unsafe partial struct ImDrawList
{
    /// <summary>
    /// <para>This is what you have to render</para>
    /// Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
    /// </summary>
    public ImVector<ImDrawCmd> CmdBuffer;
    /// <summary>
    /// Index buffer. Each command consume ImDrawCmd::ElemCount of those
    /// </summary>
    public ImVector<ushort> IdxBuffer;
    /// <summary>
    /// Vertex buffer.
    /// </summary>
    public ImVector<ImDrawVert> VtxBuffer;
    /// <summary>
    /// Flags, you may poke into these to adjust anti-aliasing settings per-primitive.
    /// </summary>
    public ImDrawListFlags Flags;
    /// <summary>
    /// <para>[Internal, used while building lists]</para>
    /// [Internal] generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.
    /// </summary>
    public uint _VtxCurrentIdx;
    private IntPtr ___Data;
    /// <summary>
    /// Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
    /// </summary>
    public ImDrawListSharedDataPtr _Data
    {
        get => ImDrawListSharedDataPtr.Create(___Data);
        set => ___Data = ImDrawListSharedDataPtr.GetHandle(value);
    }
    private ImDrawVert* ___VtxWritePtr;
    /// <summary>
    /// [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector&lt;&gt; operators too much)
    /// </summary>
    public ImDrawVertPtr _VtxWritePtr
    {
        get => ImDrawVertPtr.Create(___VtxWritePtr);
        set => ___VtxWritePtr = ImDrawVertPtr.GetHandle(value);
    }
    /// <summary>
    /// [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector&lt;&gt; operators too much)
    /// </summary>
    public ushort* _IdxWritePtr;
    /// <summary>
    /// [Internal] current path building
    /// </summary>
    public ImVector<System.Numerics.Vector2> _Path;
    /// <summary>
    /// [Internal] template of active commands. Fields should match those of CmdBuffer.back().
    /// </summary>
    public ImDrawCmdHeader _CmdHeader;
    /// <summary>
    /// [Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)
    /// </summary>
    public ImDrawListSplitter _Splitter;
    /// <summary>
    /// [Internal]
    /// </summary>
    public ImVector<System.Numerics.Vector4> _ClipRectStack;
    /// <summary>
    /// [Internal]
    /// </summary>
    public ImVector<ImTextureRef> _TextureStack;
    /// <summary>
    /// [Internal]
    /// </summary>
    public ImVector<byte> _CallbacksDataBuf;
    /// <summary>
    /// [Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content
    /// </summary>
    public float _FringeScale;
    /// <summary>
    /// Pointer to owner window's name for debugging
    /// </summary>
    public byte* _OwnerName;
}
