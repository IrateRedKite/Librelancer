// <auto-generated/>
// ReSharper disable InconsistentNaming
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference
using System;
using System.Runtime.InteropServices;
namespace ImGuiNET;

/// <summary>
/// <para>Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:</para>
/// <para>- One or more fonts.</para>
/// <para>- Custom graphics data needed to render the shapes needed by Dear ImGui.</para>
/// <para>- Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).</para>
/// <para>- If you don't call any AddFont*** functions, the default font embedded in the code will be loaded for you.</para>
/// <para>It is the rendering backend responsibility to upload texture into your graphics API:</para>
/// <para>- ImGui_ImplXXXX_RenderDrawData() functions generally iterate platform_io-&gt;Textures[] to create/update/destroy each ImTextureData instance.</para>
/// <para>- Backend then set ImTextureData's TexID and BackendUserData.</para>
/// <para>- Texture id are passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID/ImTextureRef for more details.</para>
/// <para>Legacy path:</para>
/// <para>- Call Build() + GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.</para>
/// <para>- Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.</para>
/// <para>Common pitfalls:</para>
/// <para>- If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the</para>
/// <para>atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.</para>
/// <para>- Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.</para>
/// <para>You can set font_cfg-&gt;FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed,</para>
/// <para>- Even though many functions are suffixed with "TTF", OTF data is supported just as well.</para>
/// - This is an old API and it is currently awkward for those and various other reasons! We will address them in the future!
/// </summary>
public unsafe partial struct ImFontAtlas
{
    /// <summary>
    /// <para>Input</para>
    /// Build flags (see ImFontAtlasFlags_)
    /// </summary>
    public ImFontAtlasFlags Flags;
    /// <summary>
    /// Desired texture format (default to ImTextureFormat_RGBA32 but may be changed to ImTextureFormat_Alpha8).
    /// </summary>
    public ImTextureFormat TexDesiredFormat;
    /// <summary>
    /// FIXME: Should be called "TexPackPadding". Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0 (will also need to set AntiAliasedLinesUseTex = false).
    /// </summary>
    public int TexGlyphPadding;
    /// <summary>
    /// Minimum desired texture width. Must be a power of two. Default to 512.
    /// </summary>
    public int TexMinWidth;
    /// <summary>
    /// Minimum desired texture height. Must be a power of two. Default to 128.
    /// </summary>
    public int TexMinHeight;
    /// <summary>
    /// Maximum desired texture width. Must be a power of two. Default to 8192.
    /// </summary>
    public int TexMaxWidth;
    /// <summary>
    /// Maximum desired texture height. Must be a power of two. Default to 8192.
    /// </summary>
    public int TexMaxHeight;
    /// <summary>
    /// Store your own atlas related user-data (if e.g. you have multiple font atlas).
    /// </summary>
    public IntPtr UserData;
    /// <summary>
    /// Latest texture identifier == TexData-&gt;GetTexRef().
    /// </summary>
    public ImTextureRef TexRef;
    private ImTextureData* __TexData;
    /// <summary>
    /// Latest texture.
    /// </summary>
    public ImTextureDataPtr TexData
    {
        get => ImTextureDataPtr.Create(__TexData);
        set => __TexData = ImTextureDataPtr.GetHandle(value);
    }
    /// <summary>
    /// <para>[Internal]</para>
    /// Texture list (most often TexList.Size == 1). TexData is always == TexList.back(). DO NOT USE DIRECTLY, USE GetDrawData().Textures[]/GetPlatformIO().Textures[] instead!
    /// </summary>
    public ImPtrVector<ImTextureData> TexList;
    private byte __Locked;
    /// <summary>
    /// Marked as locked during ImGui::NewFrame()..EndFrame() scope if TexUpdates are not supported. Any attempt to modify the atlas will assert.
    /// </summary>
    public bool Locked
    {
        get => __Locked != 0;
        set => __Locked = value ? (byte)1 : (byte)0;
    }
    private byte __RendererHasTextures;
    /// <summary>
    /// Copy of (BackendFlags &amp; ImGuiBackendFlags_RendererHasTextures) from supporting context.
    /// </summary>
    public bool RendererHasTextures
    {
        get => __RendererHasTextures != 0;
        set => __RendererHasTextures = value ? (byte)1 : (byte)0;
    }
    private byte __TexIsBuilt;
    /// <summary>
    /// Set when texture was built matching current font input. Mostly useful for legacy IsBuilt() call.
    /// </summary>
    public bool TexIsBuilt
    {
        get => __TexIsBuilt != 0;
        set => __TexIsBuilt = value ? (byte)1 : (byte)0;
    }
    private byte __TexPixelsUseColors;
    /// <summary>
    /// Tell whether our texture data is known to use colors (rather than just alpha channel), in order to help backend select a format or conversion process.
    /// </summary>
    public bool TexPixelsUseColors
    {
        get => __TexPixelsUseColors != 0;
        set => __TexPixelsUseColors = value ? (byte)1 : (byte)0;
    }
    /// <summary>
    /// = (1.0f/TexData-&gt;TexWidth, 1.0f/TexData-&gt;TexHeight). May change as new texture gets created.
    /// </summary>
    public System.Numerics.Vector2 TexUvScale;
    /// <summary>
    /// Texture coordinates to a white pixel. May change as new texture gets created.
    /// </summary>
    public System.Numerics.Vector2 TexUvWhitePixel;
    /// <summary>
    /// Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
    /// </summary>
    public ImPtrVector<ImFont> Fonts;
    /// <summary>
    /// Source/configuration data
    /// </summary>
    public ImVector<ImFontConfig> Sources;
    [System.Runtime.CompilerServices.InlineArray(32+1)]
    private struct __inline_TexUvLines
    {
        public System.Numerics.Vector4 _0;
    }
    private __inline_TexUvLines __array_TexUvLines;
    /// <summary>
    /// UVs for baked anti-aliased lines
    /// </summary>
    public Span<System.Numerics.Vector4> TexUvLines => __array_TexUvLines;

    /// <summary>
    /// Next value to be stored in TexData-&gt;UniqueID
    /// </summary>
    public int TexNextUniqueID;
    /// <summary>
    /// Next value to be stored in ImFont-&gt;FontID
    /// </summary>
    public int FontNextUniqueID;
    /// <summary>
    /// List of users for this atlas. Typically one per Dear ImGui context.
    /// </summary>
    public ImVector<IntPtr> DrawListSharedDatas;
    private IntPtr __Builder;
    /// <summary>
    /// Opaque interface to our data that doesn't need to be public and may be discarded when rebuilding.
    /// </summary>
    public ImFontAtlasBuilderPtr Builder
    {
        get => ImFontAtlasBuilderPtr.Create(__Builder);
        set => __Builder = ImFontAtlasBuilderPtr.GetHandle(value);
    }
    private IntPtr __FontLoader;
    /// <summary>
    /// Font loader opaque interface (default to use FreeType when IMGUI_ENABLE_FREETYPE is defined, otherwise default to use stb_truetype). Use SetFontLoader() to change this at runtime.
    /// </summary>
    public ImFontLoaderPtr FontLoader
    {
        get => ImFontLoaderPtr.Create(__FontLoader);
        set => __FontLoader = ImFontLoaderPtr.GetHandle(value);
    }
    /// <summary>
    /// Font loader name (for display e.g. in About box) == FontLoader-&gt;Name
    /// </summary>
    public byte* FontLoaderName;
    /// <summary>
    /// Font backend opaque storage
    /// </summary>
    public IntPtr FontLoaderData;
    /// <summary>
    /// Shared flags (for all fonts) for font loader. THIS IS BUILD IMPLEMENTATION DEPENDENT (e.g. Per-font override is also available in ImFontConfig).
    /// </summary>
    public uint FontLoaderFlags;
    /// <summary>
    /// Number of contexts using this atlas
    /// </summary>
    public int RefCount;
    private IntPtr __OwnerContext;
    /// <summary>
    /// Context which own the atlas will be in charge of updating and destroying it.
    /// </summary>
    public ImGuiContextPtr OwnerContext
    {
        get => ImGuiContextPtr.Create(__OwnerContext);
        set => __OwnerContext = ImGuiContextPtr.GetHandle(value);
    }
}
