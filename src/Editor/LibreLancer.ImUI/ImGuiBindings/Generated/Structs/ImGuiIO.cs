// <auto-generated/>
// ReSharper disable InconsistentNaming
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference
using System;
using System.Runtime.InteropServices;
namespace ImGuiNET;

public unsafe partial struct ImGuiIO
{
    /// <summary>
    /// = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Keyboard/Gamepad navigation options, etc.
    /// </summary>
    public ImGuiConfigFlags ConfigFlags;
    /// <summary>
    /// = 0              // See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.
    /// </summary>
    public ImGuiBackendFlags BackendFlags;
    /// <summary>
    /// &lt;unset&gt;          // Main display size, in pixels (== GetMainViewport()-&gt;Size). May change every frame.
    /// </summary>
    public System.Numerics.Vector2 DisplaySize;
    /// <summary>
    /// = (1, 1)         // Main display density. For retina display where window coordinates are different from framebuffer coordinates. This will affect font density + will end up in ImDrawData::FramebufferScale.
    /// </summary>
    public System.Numerics.Vector2 DisplayFramebufferScale;
    /// <summary>
    /// = 1.0f/60.0f     // Time elapsed since last frame, in seconds. May change every frame.
    /// </summary>
    public float DeltaTime;
    /// <summary>
    /// = 5.0f           // Minimum time between saving positions/sizes to .ini file, in seconds.
    /// </summary>
    public float IniSavingRate;
    /// <summary>
    /// = "imgui.ini"    // Path to .ini file (important: default "imgui.ini" is relative to current working dir!). Set NULL to disable automatic .ini loading/saving or if you want to manually call LoadIniSettingsXXX() / SaveIniSettingsXXX() functions.
    /// </summary>
    public byte* IniFilename;
    /// <summary>
    /// = "imgui_log.txt"// Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
    /// </summary>
    public byte* LogFilename;
    /// <summary>
    /// = NULL           // Store your own data.
    /// </summary>
    public IntPtr UserData;
    private ImFontAtlas* __Fonts;
    /// <summary>
    /// <para>Font system</para>
    /// &lt;auto&gt;           // Font atlas: load, rasterize and pack one or more fonts into a single texture.
    /// </summary>
    public ImFontAtlasPtr Fonts
    {
        get => ImFontAtlasPtr.Create(__Fonts);
        set => __Fonts = ImFontAtlasPtr.GetHandle(value);
    }
    private ImFont* __FontDefault;
    /// <summary>
    /// = NULL           // Font to use on NewFrame(). Use NULL to uses Fonts-&gt;Fonts[0].
    /// </summary>
    public ImFontPtr FontDefault
    {
        get => ImFontPtr.Create(__FontDefault);
        set => __FontDefault = ImFontPtr.GetHandle(value);
    }
    private byte __FontAllowUserScaling;
    /// <summary>
    /// = false          // [OBSOLETE] Allow user scaling text of individual window with CTRL+Wheel.
    /// </summary>
    public bool FontAllowUserScaling
    {
        get => __FontAllowUserScaling != 0;
        set => __FontAllowUserScaling = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigNavSwapGamepadButtons;
    /// <summary>
    /// <para>Keyboard/Gamepad Navigation options</para>
    /// = false          // Swap Activate&lt;&gt;Cancel (A&lt;&gt;B) buttons, matching typical "Nintendo/Japanese style" gamepad layout.
    /// </summary>
    public bool ConfigNavSwapGamepadButtons
    {
        get => __ConfigNavSwapGamepadButtons != 0;
        set => __ConfigNavSwapGamepadButtons = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigNavMoveSetMousePos;
    /// <summary>
    /// = false          // Directional/tabbing navigation teleports the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is difficult. Will update io.MousePos and set io.WantSetMousePos=true.
    /// </summary>
    public bool ConfigNavMoveSetMousePos
    {
        get => __ConfigNavMoveSetMousePos != 0;
        set => __ConfigNavMoveSetMousePos = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigNavCaptureKeyboard;
    /// <summary>
    /// = true           // Sets io.WantCaptureKeyboard when io.NavActive is set.
    /// </summary>
    public bool ConfigNavCaptureKeyboard
    {
        get => __ConfigNavCaptureKeyboard != 0;
        set => __ConfigNavCaptureKeyboard = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigNavEscapeClearFocusItem;
    /// <summary>
    /// = true           // Pressing Escape can clear focused item + navigation id/highlight. Set to false if you want to always keep highlight on.
    /// </summary>
    public bool ConfigNavEscapeClearFocusItem
    {
        get => __ConfigNavEscapeClearFocusItem != 0;
        set => __ConfigNavEscapeClearFocusItem = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigNavEscapeClearFocusWindow;
    /// <summary>
    /// = false          // Pressing Escape can clear focused window as well (super set of io.ConfigNavEscapeClearFocusItem).
    /// </summary>
    public bool ConfigNavEscapeClearFocusWindow
    {
        get => __ConfigNavEscapeClearFocusWindow != 0;
        set => __ConfigNavEscapeClearFocusWindow = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigNavCursorVisibleAuto;
    /// <summary>
    /// = true           // Using directional navigation key makes the cursor visible. Mouse click hides the cursor.
    /// </summary>
    public bool ConfigNavCursorVisibleAuto
    {
        get => __ConfigNavCursorVisibleAuto != 0;
        set => __ConfigNavCursorVisibleAuto = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigNavCursorVisibleAlways;
    /// <summary>
    /// = false          // Navigation cursor is always visible.
    /// </summary>
    public bool ConfigNavCursorVisibleAlways
    {
        get => __ConfigNavCursorVisibleAlways != 0;
        set => __ConfigNavCursorVisibleAlways = value ? (byte)1 : (byte)0;
    }
    private byte __MouseDrawCursor;
    /// <summary>
    /// <para>Miscellaneous options</para>
    /// <para>(you can visualize and interact with all options in 'Demo-&gt;Configuration')</para>
    /// = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by backend implementations.
    /// </summary>
    public bool MouseDrawCursor
    {
        get => __MouseDrawCursor != 0;
        set => __MouseDrawCursor = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigMacOSXBehaviors;
    /// <summary>
    /// = defined(__APPLE__) // Swap Cmd&lt;&gt;Ctrl keys + OS X style text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl.
    /// </summary>
    public bool ConfigMacOSXBehaviors
    {
        get => __ConfigMacOSXBehaviors != 0;
        set => __ConfigMacOSXBehaviors = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigInputTrickleEventQueue;
    /// <summary>
    /// = true           // Enable input queue trickling: some types of events submitted during the same frame (e.g. button down + up) will be spread over multiple frames, improving interactions with low framerates.
    /// </summary>
    public bool ConfigInputTrickleEventQueue
    {
        get => __ConfigInputTrickleEventQueue != 0;
        set => __ConfigInputTrickleEventQueue = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigInputTextCursorBlink;
    /// <summary>
    /// = true           // Enable blinking cursor (optional as some users consider it to be distracting).
    /// </summary>
    public bool ConfigInputTextCursorBlink
    {
        get => __ConfigInputTextCursorBlink != 0;
        set => __ConfigInputTextCursorBlink = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigInputTextEnterKeepActive;
    /// <summary>
    /// = false          // [BETA] Pressing Enter will keep item active and select contents (single-line only).
    /// </summary>
    public bool ConfigInputTextEnterKeepActive
    {
        get => __ConfigInputTextEnterKeepActive != 0;
        set => __ConfigInputTextEnterKeepActive = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigDragClickToInputText;
    /// <summary>
    /// = false          // [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.
    /// </summary>
    public bool ConfigDragClickToInputText
    {
        get => __ConfigDragClickToInputText != 0;
        set => __ConfigDragClickToInputText = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigWindowsResizeFromEdges;
    /// <summary>
    /// = true           // Enable resizing of windows from their edges and from the lower-left corner. This requires ImGuiBackendFlags_HasMouseCursors for better mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)
    /// </summary>
    public bool ConfigWindowsResizeFromEdges
    {
        get => __ConfigWindowsResizeFromEdges != 0;
        set => __ConfigWindowsResizeFromEdges = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigWindowsMoveFromTitleBarOnly;
    /// <summary>
    /// = false      // Enable allowing to move windows only when clicking on their title bar. Does not apply to windows without a title bar.
    /// </summary>
    public bool ConfigWindowsMoveFromTitleBarOnly
    {
        get => __ConfigWindowsMoveFromTitleBarOnly != 0;
        set => __ConfigWindowsMoveFromTitleBarOnly = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigWindowsCopyContentsWithCtrlC;
    /// <summary>
    /// = false      // [EXPERIMENTAL] CTRL+C copy the contents of focused window into the clipboard. Experimental because: (1) has known issues with nested Begin/End pairs (2) text output quality varies (3) text output is in submission order rather than spatial order.
    /// </summary>
    public bool ConfigWindowsCopyContentsWithCtrlC
    {
        get => __ConfigWindowsCopyContentsWithCtrlC != 0;
        set => __ConfigWindowsCopyContentsWithCtrlC = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigScrollbarScrollByPage;
    /// <summary>
    /// = true           // Enable scrolling page by page when clicking outside the scrollbar grab. When disabled, always scroll to clicked location. When enabled, Shift+Click scrolls to clicked location.
    /// </summary>
    public bool ConfigScrollbarScrollByPage
    {
        get => __ConfigScrollbarScrollByPage != 0;
        set => __ConfigScrollbarScrollByPage = value ? (byte)1 : (byte)0;
    }
    /// <summary>
    /// = 60.0f          // Timer (in seconds) to free transient windows/tables memory buffers when unused. Set to -1.0f to disable.
    /// </summary>
    public float ConfigMemoryCompactTimer;
    /// <summary>
    /// <para>Inputs Behaviors</para>
    /// <para>(other variables, ones which are expected to be tweaked within UI code, are exposed in ImGuiStyle)</para>
    /// = 0.30f          // Time for a double-click, in seconds.
    /// </summary>
    public float MouseDoubleClickTime;
    /// <summary>
    /// = 6.0f           // Distance threshold to stay in to validate a double-click, in pixels.
    /// </summary>
    public float MouseDoubleClickMaxDist;
    /// <summary>
    /// = 6.0f           // Distance threshold before considering we are dragging.
    /// </summary>
    public float MouseDragThreshold;
    /// <summary>
    /// = 0.275f         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
    /// </summary>
    public float KeyRepeatDelay;
    /// <summary>
    /// = 0.050f         // When holding a key/button, rate at which it repeats, in seconds.
    /// </summary>
    public float KeyRepeatRate;
    private byte __ConfigErrorRecovery;
    /// <summary>
    /// <para>Options to configure Error Handling and how we handle recoverable errors [EXPERIMENTAL]</para>
    /// <para>- Error recovery is provided as a way to facilitate:</para>
    /// <para>- Recovery after a programming error (native code or scripting language - the later tends to facilitate iterating on code while running).</para>
    /// <para>- Recovery after running an exception handler or any error processing which may skip code after an error has been detected.</para>
    /// <para>- Error recovery is not perfect nor guaranteed! It is a feature to ease development.</para>
    /// <para>You not are not supposed to rely on it in the course of a normal application run.</para>
    /// <para>- Functions that support error recovery are using IM_ASSERT_USER_ERROR() instead of IM_ASSERT().</para>
    /// <para>- By design, we do NOT allow error recovery to be 100% silent. One of the three options needs to be checked!</para>
    /// <para>- Always ensure that on programmers seats you have at minimum Asserts or Tooltips enabled when making direct imgui API calls!</para>
    /// <para>Otherwise it would severely hinder your ability to catch and correct mistakes!</para>
    /// <para>Read https://github.com/ocornut/imgui/wiki/Error-Handling for details.</para>
    /// <para>- Programmer seats: keep asserts (default), or disable asserts and keep error tooltips (new and nice!)</para>
    /// <para>- Non-programmer seats: maybe disable asserts, but make sure errors are resurfaced (tooltips, visible log entries, use callback etc.)</para>
    /// <para>- Recovery after error/exception: record stack sizes with ErrorRecoveryStoreState(), disable assert, set log callback (to e.g. trigger high-level breakpoint), recover with ErrorRecoveryTryToRecoverState(), restore settings.</para>
    /// = true       // Enable error recovery support. Some errors won't be detected and lead to direct crashes if recovery is disabled.
    /// </summary>
    public bool ConfigErrorRecovery
    {
        get => __ConfigErrorRecovery != 0;
        set => __ConfigErrorRecovery = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigErrorRecoveryEnableAssert;
    /// <summary>
    /// = true       // Enable asserts on recoverable error. By default call IM_ASSERT() when returning from a failing IM_ASSERT_USER_ERROR()
    /// </summary>
    public bool ConfigErrorRecoveryEnableAssert
    {
        get => __ConfigErrorRecoveryEnableAssert != 0;
        set => __ConfigErrorRecoveryEnableAssert = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigErrorRecoveryEnableDebugLog;
    /// <summary>
    /// = true       // Enable debug log output on recoverable errors.
    /// </summary>
    public bool ConfigErrorRecoveryEnableDebugLog
    {
        get => __ConfigErrorRecoveryEnableDebugLog != 0;
        set => __ConfigErrorRecoveryEnableDebugLog = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigErrorRecoveryEnableTooltip;
    /// <summary>
    /// = true       // Enable tooltip on recoverable errors. The tooltip include a way to enable asserts if they were disabled.
    /// </summary>
    public bool ConfigErrorRecoveryEnableTooltip
    {
        get => __ConfigErrorRecoveryEnableTooltip != 0;
        set => __ConfigErrorRecoveryEnableTooltip = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigDebugIsDebuggerPresent;
    /// <summary>
    /// <para>Option to enable various debug tools showing buttons that will call the IM_DEBUG_BREAK() macro.</para>
    /// <para>- The Item Picker tool will be available regardless of this being enabled, in order to maximize its discoverability.</para>
    /// <para>- Requires a debugger being attached, otherwise IM_DEBUG_BREAK() options will appear to crash your application.</para>
    /// <para>e.g. io.ConfigDebugIsDebuggerPresent = ::IsDebuggerPresent() on Win32, or refer to ImOsIsDebuggerPresent() imgui_test_engine/imgui_te_utils.cpp for a Unix compatible version).</para>
    /// = false          // Enable various tools calling IM_DEBUG_BREAK().
    /// </summary>
    public bool ConfigDebugIsDebuggerPresent
    {
        get => __ConfigDebugIsDebuggerPresent != 0;
        set => __ConfigDebugIsDebuggerPresent = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigDebugHighlightIdConflicts;
    /// <summary>
    /// <para>Tools to detect code submitting items with conflicting/duplicate IDs</para>
    /// <para>- Code should use PushID()/PopID() in loops, or append "##xx" to same-label identifiers.</para>
    /// <para>- Empty label e.g. Button("") == same ID as parent widget/node. Use Button("##xx") instead!</para>
    /// <para>- See FAQ https://github.com/ocornut/imgui/blob/master/docs/FAQ.md#q-about-the-id-stack-system</para>
    /// = true           // Highlight and show an error message popup when multiple items have conflicting identifiers.
    /// </summary>
    public bool ConfigDebugHighlightIdConflicts
    {
        get => __ConfigDebugHighlightIdConflicts != 0;
        set => __ConfigDebugHighlightIdConflicts = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigDebugHighlightIdConflictsShowItemPicker;
    /// <summary>
    /// =true // Show "Item Picker" button in aforementioned popup.
    /// </summary>
    public bool ConfigDebugHighlightIdConflictsShowItemPicker
    {
        get => __ConfigDebugHighlightIdConflictsShowItemPicker != 0;
        set => __ConfigDebugHighlightIdConflictsShowItemPicker = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigDebugBeginReturnValueOnce;
    /// <summary>
    /// <para>Tools to test correct Begin/End and BeginChild/EndChild behaviors.</para>
    /// <para>- Presently Begin()/End() and BeginChild()/EndChild() needs to ALWAYS be called in tandem, regardless of return value of BeginXXX()</para>
    /// <para>- This is inconsistent with other BeginXXX functions and create confusion for many users.</para>
    /// <para>- We expect to update the API eventually. In the meanwhile we provide tools to facilitate checking user-code behavior.</para>
    /// = false          // First-time calls to Begin()/BeginChild() will return false. NEEDS TO BE SET AT APPLICATION BOOT TIME if you don't want to miss windows.
    /// </summary>
    public bool ConfigDebugBeginReturnValueOnce
    {
        get => __ConfigDebugBeginReturnValueOnce != 0;
        set => __ConfigDebugBeginReturnValueOnce = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigDebugBeginReturnValueLoop;
    /// <summary>
    /// = false          // Some calls to Begin()/BeginChild() will return false. Will cycle through window depths then repeat. Suggested use: add "io.ConfigDebugBeginReturnValue = io.KeyShift" in your main loop then occasionally press SHIFT. Windows should be flickering while running.
    /// </summary>
    public bool ConfigDebugBeginReturnValueLoop
    {
        get => __ConfigDebugBeginReturnValueLoop != 0;
        set => __ConfigDebugBeginReturnValueLoop = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigDebugIgnoreFocusLoss;
    /// <summary>
    /// <para>Option to deactivate io.AddFocusEvent(false) handling.</para>
    /// <para>- May facilitate interactions with a debugger when focus loss leads to clearing inputs data.</para>
    /// <para>- Backends may have other side-effects on focus loss, so this will reduce side-effects but not necessary remove all of them.</para>
    /// = false          // Ignore io.AddFocusEvent(false), consequently not calling io.ClearInputKeys()/io.ClearInputMouse() in input processing.
    /// </summary>
    public bool ConfigDebugIgnoreFocusLoss
    {
        get => __ConfigDebugIgnoreFocusLoss != 0;
        set => __ConfigDebugIgnoreFocusLoss = value ? (byte)1 : (byte)0;
    }
    private byte __ConfigDebugIniSettings;
    /// <summary>
    /// <para>Option to audit .ini data</para>
    /// = false          // Save .ini data with extra comments (particularly helpful for Docking, but makes saving slower)
    /// </summary>
    public bool ConfigDebugIniSettings
    {
        get => __ConfigDebugIniSettings != 0;
        set => __ConfigDebugIniSettings = value ? (byte)1 : (byte)0;
    }
    /// <summary>
    /// <para>Nowadays those would be stored in ImGuiPlatformIO but we are leaving them here for legacy reasons.</para>
    /// <para>Optional: Platform/Renderer backend name (informational only! will be displayed in About Window) + User data for backend/wrappers to store their own stuff.</para>
    /// = NULL
    /// </summary>
    public byte* BackendPlatformName;
    /// <summary>
    /// = NULL
    /// </summary>
    public byte* BackendRendererName;
    /// <summary>
    /// = NULL           // User data for platform backend
    /// </summary>
    public IntPtr BackendPlatformUserData;
    /// <summary>
    /// = NULL           // User data for renderer backend
    /// </summary>
    public IntPtr BackendRendererUserData;
    /// <summary>
    /// = NULL           // User data for non C++ programming language backend
    /// </summary>
    public IntPtr BackendLanguageUserData;
    private byte __WantCaptureMouse;
    /// <summary>
    /// Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main game/application (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).
    /// </summary>
    public bool WantCaptureMouse
    {
        get => __WantCaptureMouse != 0;
        set => __WantCaptureMouse = value ? (byte)1 : (byte)0;
    }
    private byte __WantCaptureKeyboard;
    /// <summary>
    /// Set when Dear ImGui will use keyboard inputs, in this case do not dispatch them to your main game/application (either way, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).
    /// </summary>
    public bool WantCaptureKeyboard
    {
        get => __WantCaptureKeyboard != 0;
        set => __WantCaptureKeyboard = value ? (byte)1 : (byte)0;
    }
    private byte __WantTextInput;
    /// <summary>
    /// Mobile/console: when set, you may display an on-screen keyboard. This is set by Dear ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
    /// </summary>
    public bool WantTextInput
    {
        get => __WantTextInput != 0;
        set => __WantTextInput = value ? (byte)1 : (byte)0;
    }
    private byte __WantSetMousePos;
    /// <summary>
    /// MousePos has been altered, backend should reposition mouse on next frame. Rarely used! Set only when io.ConfigNavMoveSetMousePos is enabled.
    /// </summary>
    public bool WantSetMousePos
    {
        get => __WantSetMousePos != 0;
        set => __WantSetMousePos = value ? (byte)1 : (byte)0;
    }
    private byte __WantSaveIniSettings;
    /// <summary>
    /// When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. Important: clear io.WantSaveIniSettings yourself after saving!
    /// </summary>
    public bool WantSaveIniSettings
    {
        get => __WantSaveIniSettings != 0;
        set => __WantSaveIniSettings = value ? (byte)1 : (byte)0;
    }
    private byte __NavActive;
    /// <summary>
    /// Keyboard/Gamepad navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
    /// </summary>
    public bool NavActive
    {
        get => __NavActive != 0;
        set => __NavActive = value ? (byte)1 : (byte)0;
    }
    private byte __NavVisible;
    /// <summary>
    /// Keyboard/Gamepad navigation highlight is visible and allowed (will handle ImGuiKey_NavXXX events).
    /// </summary>
    public bool NavVisible
    {
        get => __NavVisible != 0;
        set => __NavVisible = value ? (byte)1 : (byte)0;
    }
    /// <summary>
    /// Estimate of application framerate (rolling average over 60 frames, based on io.DeltaTime), in frame per second. Solely for convenience. Slow applications may not want to use a moving average or may want to reset underlying buffers occasionally.
    /// </summary>
    public float Framerate;
    /// <summary>
    /// Vertices output during last call to Render()
    /// </summary>
    public int MetricsRenderVertices;
    /// <summary>
    /// Indices output during last call to Render() = number of triangles * 3
    /// </summary>
    public int MetricsRenderIndices;
    /// <summary>
    /// Number of visible windows
    /// </summary>
    public int MetricsRenderWindows;
    /// <summary>
    /// Number of active windows
    /// </summary>
    public int MetricsActiveWindows;
    /// <summary>
    /// Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.
    /// </summary>
    public System.Numerics.Vector2 MouseDelta;
    private IntPtr __Ctx;
    /// <summary>
    /// Parent UI context (needs to be set explicitly by parent).
    /// </summary>
    public ImGuiContextPtr Ctx
    {
        get => ImGuiContextPtr.Create(__Ctx);
        set => __Ctx = ImGuiContextPtr.GetHandle(value);
    }
    /// <summary>
    /// <para>Main Input State</para>
    /// <para>(this block used to be written by backend, since 1.87 it is best to NOT write to those directly, call the AddXXX functions above instead)</para>
    /// <para>(reading from those variables is fair game, as they are extremely unlikely to be moving anywhere)</para>
    /// Mouse position, in pixels. Set to ImVec2(-FLT_MAX, -FLT_MAX) if mouse is unavailable (on another screen, etc.)
    /// </summary>
    public System.Numerics.Vector2 MousePos;
    [System.Runtime.CompilerServices.InlineArray(5)]
    private struct __inline_MouseDown
    {
        public byte _0;
    }
    private __inline_MouseDown __array_MouseDown;
    /// <summary>
    /// Mouse buttons: 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5). Dear ImGui mostly uses left and right buttons. Other buttons allow us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
    /// </summary>
    public Span<byte> MouseDown => __array_MouseDown;

    /// <summary>
    /// Mouse wheel Vertical: 1 unit scrolls about 5 lines text. &gt;0 scrolls Up, &lt;0 scrolls Down. Hold SHIFT to turn vertical scroll into horizontal scroll.
    /// </summary>
    public float MouseWheel;
    /// <summary>
    /// Mouse wheel Horizontal. &gt;0 scrolls Left, &lt;0 scrolls Right. Most users don't have a mouse with a horizontal wheel, may not be filled by all backends.
    /// </summary>
    public float MouseWheelH;
    /// <summary>
    /// Mouse actual input peripheral (Mouse/TouchScreen/Pen).
    /// </summary>
    public ImGuiMouseSource MouseSource;
    private byte __KeyCtrl;
    /// <summary>
    /// Keyboard modifier down: Control
    /// </summary>
    public bool KeyCtrl
    {
        get => __KeyCtrl != 0;
        set => __KeyCtrl = value ? (byte)1 : (byte)0;
    }
    private byte __KeyShift;
    /// <summary>
    /// Keyboard modifier down: Shift
    /// </summary>
    public bool KeyShift
    {
        get => __KeyShift != 0;
        set => __KeyShift = value ? (byte)1 : (byte)0;
    }
    private byte __KeyAlt;
    /// <summary>
    /// Keyboard modifier down: Alt
    /// </summary>
    public bool KeyAlt
    {
        get => __KeyAlt != 0;
        set => __KeyAlt = value ? (byte)1 : (byte)0;
    }
    private byte __KeySuper;
    /// <summary>
    /// Keyboard modifier down: Cmd/Super/Windows
    /// </summary>
    public bool KeySuper
    {
        get => __KeySuper != 0;
        set => __KeySuper = value ? (byte)1 : (byte)0;
    }
    /// <summary>
    /// <para>Other state maintained from data above + IO function calls</para>
    /// Key mods flags (any of ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Alt/ImGuiMod_Super flags, same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags. Read-only, updated by NewFrame()
    /// </summary>
    public int KeyMods;
    [System.Runtime.CompilerServices.InlineArray(((int)(ImGuiKey.NamedKey_COUNT)))]
    private struct __inline_KeysData
    {
        public ImGuiKeyData _0;
    }
    private __inline_KeysData __array_KeysData;
    /// <summary>
    /// Key state for all known keys. MUST use 'key - ImGuiKey_NamedKey_BEGIN' as index. Use IsKeyXXX() functions to access this.
    /// </summary>
    public Span<ImGuiKeyData> KeysData => __array_KeysData;

    private byte __WantCaptureMouseUnlessPopupClose;
    /// <summary>
    /// Alternative to WantCaptureMouse: (WantCaptureMouse == true &amp;&amp; WantCaptureMouseUnlessPopupClose == false) when a click over void is expected to close a popup.
    /// </summary>
    public bool WantCaptureMouseUnlessPopupClose
    {
        get => __WantCaptureMouseUnlessPopupClose != 0;
        set => __WantCaptureMouseUnlessPopupClose = value ? (byte)1 : (byte)0;
    }
    /// <summary>
    /// Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)
    /// </summary>
    public System.Numerics.Vector2 MousePosPrev;
    [System.Runtime.CompilerServices.InlineArray(5)]
    private struct __inline_MouseClickedPos
    {
        public System.Numerics.Vector2 _0;
    }
    private __inline_MouseClickedPos __array_MouseClickedPos;
    /// <summary>
    /// Position at time of clicking
    /// </summary>
    public Span<System.Numerics.Vector2> MouseClickedPos => __array_MouseClickedPos;

    [System.Runtime.CompilerServices.InlineArray(5)]
    private struct __inline_MouseClickedTime
    {
        public double _0;
    }
    private __inline_MouseClickedTime __array_MouseClickedTime;
    /// <summary>
    /// Time of last click (used to figure out double-click)
    /// </summary>
    public Span<double> MouseClickedTime => __array_MouseClickedTime;

    [System.Runtime.CompilerServices.InlineArray(5)]
    private struct __inline_MouseClicked
    {
        public byte _0;
    }
    private __inline_MouseClicked __array_MouseClicked;
    /// <summary>
    /// Mouse button went from !Down to Down (same as MouseClickedCount[x] != 0)
    /// </summary>
    public Span<byte> MouseClicked => __array_MouseClicked;

    [System.Runtime.CompilerServices.InlineArray(5)]
    private struct __inline_MouseDoubleClicked
    {
        public byte _0;
    }
    private __inline_MouseDoubleClicked __array_MouseDoubleClicked;
    /// <summary>
    /// Has mouse button been double-clicked? (same as MouseClickedCount[x] == 2)
    /// </summary>
    public Span<byte> MouseDoubleClicked => __array_MouseDoubleClicked;

    [System.Runtime.CompilerServices.InlineArray(5)]
    private struct __inline_MouseClickedCount
    {
        public ushort _0;
    }
    private __inline_MouseClickedCount __array_MouseClickedCount;
    /// <summary>
    /// == 0 (not clicked), == 1 (same as MouseClicked[]), == 2 (double-clicked), == 3 (triple-clicked) etc. when going from !Down to Down
    /// </summary>
    public Span<ushort> MouseClickedCount => __array_MouseClickedCount;

    [System.Runtime.CompilerServices.InlineArray(5)]
    private struct __inline_MouseClickedLastCount
    {
        public ushort _0;
    }
    private __inline_MouseClickedLastCount __array_MouseClickedLastCount;
    /// <summary>
    /// Count successive number of clicks. Stays valid after mouse release. Reset after another click is done.
    /// </summary>
    public Span<ushort> MouseClickedLastCount => __array_MouseClickedLastCount;

    [System.Runtime.CompilerServices.InlineArray(5)]
    private struct __inline_MouseReleased
    {
        public byte _0;
    }
    private __inline_MouseReleased __array_MouseReleased;
    /// <summary>
    /// Mouse button went from Down to !Down
    /// </summary>
    public Span<byte> MouseReleased => __array_MouseReleased;

    [System.Runtime.CompilerServices.InlineArray(5)]
    private struct __inline_MouseReleasedTime
    {
        public double _0;
    }
    private __inline_MouseReleasedTime __array_MouseReleasedTime;
    /// <summary>
    /// Time of last released (rarely used! but useful to handle delayed single-click when trying to disambiguate them from double-click).
    /// </summary>
    public Span<double> MouseReleasedTime => __array_MouseReleasedTime;

    [System.Runtime.CompilerServices.InlineArray(5)]
    private struct __inline_MouseDownOwned
    {
        public byte _0;
    }
    private __inline_MouseDownOwned __array_MouseDownOwned;
    /// <summary>
    /// Track if button was clicked inside a dear imgui window or over void blocked by a popup. We don't request mouse capture from the application if click started outside ImGui bounds.
    /// </summary>
    public Span<byte> MouseDownOwned => __array_MouseDownOwned;

    [System.Runtime.CompilerServices.InlineArray(5)]
    private struct __inline_MouseDownOwnedUnlessPopupClose
    {
        public byte _0;
    }
    private __inline_MouseDownOwnedUnlessPopupClose __array_MouseDownOwnedUnlessPopupClose;
    /// <summary>
    /// Track if button was clicked inside a dear imgui window.
    /// </summary>
    public Span<byte> MouseDownOwnedUnlessPopupClose => __array_MouseDownOwnedUnlessPopupClose;

    private byte __MouseWheelRequestAxisSwap;
    /// <summary>
    /// On a non-Mac system, holding SHIFT requests WheelY to perform the equivalent of a WheelX event. On a Mac system this is already enforced by the system.
    /// </summary>
    public bool MouseWheelRequestAxisSwap
    {
        get => __MouseWheelRequestAxisSwap != 0;
        set => __MouseWheelRequestAxisSwap = value ? (byte)1 : (byte)0;
    }
    private byte __MouseCtrlLeftAsRightClick;
    /// <summary>
    /// (OSX) Set to true when the current click was a Ctrl+click that spawned a simulated right click
    /// </summary>
    public bool MouseCtrlLeftAsRightClick
    {
        get => __MouseCtrlLeftAsRightClick != 0;
        set => __MouseCtrlLeftAsRightClick = value ? (byte)1 : (byte)0;
    }
    [System.Runtime.CompilerServices.InlineArray(5)]
    private struct __inline_MouseDownDuration
    {
        public float _0;
    }
    private __inline_MouseDownDuration __array_MouseDownDuration;
    /// <summary>
    /// Duration the mouse button has been down (0.0f == just clicked)
    /// </summary>
    public Span<float> MouseDownDuration => __array_MouseDownDuration;

    [System.Runtime.CompilerServices.InlineArray(5)]
    private struct __inline_MouseDownDurationPrev
    {
        public float _0;
    }
    private __inline_MouseDownDurationPrev __array_MouseDownDurationPrev;
    /// <summary>
    /// Previous time the mouse button has been down
    /// </summary>
    public Span<float> MouseDownDurationPrev => __array_MouseDownDurationPrev;

    [System.Runtime.CompilerServices.InlineArray(5)]
    private struct __inline_MouseDragMaxDistanceSqr
    {
        public float _0;
    }
    private __inline_MouseDragMaxDistanceSqr __array_MouseDragMaxDistanceSqr;
    /// <summary>
    /// Squared maximum distance of how much mouse has traveled from the clicking point (used for moving thresholds)
    /// </summary>
    public Span<float> MouseDragMaxDistanceSqr => __array_MouseDragMaxDistanceSqr;

    /// <summary>
    /// Touch/Pen pressure (0.0f to 1.0f, should be &gt;0.0f only when MouseDown[0] == true). Helper storage currently unused by Dear ImGui.
    /// </summary>
    public float PenPressure;
    private byte __AppFocusLost;
    /// <summary>
    /// Only modify via AddFocusEvent()
    /// </summary>
    public bool AppFocusLost
    {
        get => __AppFocusLost != 0;
        set => __AppFocusLost = value ? (byte)1 : (byte)0;
    }
    private byte __AppAcceptingEvents;
    /// <summary>
    /// Only modify via SetAppAcceptingEvents()
    /// </summary>
    public bool AppAcceptingEvents
    {
        get => __AppAcceptingEvents != 0;
        set => __AppAcceptingEvents = value ? (byte)1 : (byte)0;
    }
    /// <summary>
    /// For AddInputCharacterUTF16()
    /// </summary>
    public ushort InputQueueSurrogate;
    /// <summary>
    /// Queue of _characters_ input (obtained by platform backend). Fill using AddInputCharacter() helper.
    /// </summary>
    public ImVector<ushort> InputQueueCharacters;
}
