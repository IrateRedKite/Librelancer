// <auto-generated/>
// ReSharper disable InconsistentNaming

using System;
using System.Buffers;
using System.Text;
using System.Runtime.InteropServices;

namespace ImGuiNET;

internal unsafe ref struct UTF8ZArrayHelper
{
    private IntPtr extra;

    public UTF8ZArrayHelper(byte* initialBuffer, int initialBufferLength, byte** pointers, string[] values)
    {
        Span<byte> buffer = new Span<byte>(initialBuffer, initialBufferLength - 1);
        extra = IntPtr.Zero;
        int i;
        int bufferNext = 0;
        for (i = 0; i < values.Length; i++)
        {
            if (bufferNext >= buffer.Length)
                break;
            var nb = buffer.Slice(bufferNext);
            if (Encoding.UTF8.TryGetBytes(values[i], nb, out var written))
            {
                pointers[i] = initialBuffer + bufferNext;
                bufferNext += written + 1;
            }
            else
            {
                break;
            }
        }

        if (i < values.Length)
        {
            int remainingSize = 0;
            for (int j = i; j < values.Length; j++)
            {
                remainingSize += Encoding.UTF8.GetMaxByteCount(values[j].Length) + 1;
            }
            bufferNext = 0;
            extra = Marshal.AllocHGlobal(remainingSize);
            var remainingSpan = new Span<byte>((byte*)extra, remainingSize);
            for (; i < values.Length; i++)
            {
                pointers[i] = ((byte*)extra) + bufferNext;
                var nb = remainingSpan.Slice(bufferNext);
                int byteCount = Encoding.UTF8.GetBytes(values[i], nb);
                nb[byteCount] = 0;
                bufferNext += byteCount + 1;
            }
        }
    }

    public void Dispose()
    {
        if(extra != IntPtr.Zero)
            Marshal.FreeHGlobal(extra);
    }
}
internal unsafe ref struct UTF8ZHelper
{
    byte* buffer;
    IntPtr marshalled;
    string original;

    public int ByteCount;

    public UTF8ZHelper(byte* initialBuffer, int initialBufferLength, string value)
    {
        original = value;
        if(value == null)
        {
            buffer = null;
            marshalled = IntPtr.Zero;
        }
        else
        {
            Span<byte> initial = new Span<byte>(initialBuffer, initialBufferLength - 1);
            buffer = initialBuffer;
            if (!Encoding.UTF8.TryGetBytes(value, initial, out ByteCount))
            {
                int maxSize = Encoding.UTF8.GetMaxByteCount(value.Length) + 1;
                marshalled = Marshal.AllocHGlobal(maxSize);
                var bytes = new Span<byte>(buffer, maxSize);
                ByteCount = Encoding.UTF8.GetBytes(value, bytes);
                bytes[ByteCount] = 0;
                buffer = (byte*)marshalled;
            }
            else
            {
                marshalled = IntPtr.Zero;
            }
        }
    }

    public byte* Pointer => buffer;

    public void Dispose()
    {
        if (marshalled != IntPtr.Zero)
        {
            Marshal.FreeHGlobal(marshalled);
        }
    }

    public byte* GetTextEnd(int? textEnd)
    {
        if(buffer == null || textEnd == null)
            return null;
        var bC = Encoding.UTF8.GetByteCount(original, 0, textEnd.Value);
        return buffer + bC;
    }
}
