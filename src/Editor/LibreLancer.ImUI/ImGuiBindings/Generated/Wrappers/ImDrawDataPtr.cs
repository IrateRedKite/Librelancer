// <auto-generated/>
// ReSharper disable InconsistentNaming
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace ImGuiNET;

public unsafe partial class ImDrawDataPtr
{
    public ImDrawData* Handle { get; private set; }

    public ImDrawDataPtr (ImDrawData* handle)
    {
        Handle = handle;
    }

    internal static ImDrawDataPtr Create(ImDrawData* handle)
    {
        return handle == null ? null : new(handle);
    }

    internal static ImDrawData* GetHandle(ImDrawDataPtr self)
    {
        return self == null ? null : self.Handle;
    }

    /// <summary>
    /// Only valid after Render() is called and before the next NewFrame() is called.
    /// </summary>
    public bool Valid
    {
        get => Handle->Valid;
        set => Handle->Valid = value;
    }

    /// <summary>
    /// Number of ImDrawList* to render. (== CmdLists.Size). Exists for legacy reason.
    /// </summary>
    public ref int CmdListsCount => ref Unsafe.AsRef<int>(&Handle->CmdListsCount);

    /// <summary>
    /// For convenience, sum of all ImDrawList's IdxBuffer.Size
    /// </summary>
    public ref int TotalIdxCount => ref Unsafe.AsRef<int>(&Handle->TotalIdxCount);

    /// <summary>
    /// For convenience, sum of all ImDrawList's VtxBuffer.Size
    /// </summary>
    public ref int TotalVtxCount => ref Unsafe.AsRef<int>(&Handle->TotalVtxCount);

    /// <summary>
    /// Array of ImDrawList* to render. The ImDrawLists are owned by ImGuiContext and only pointed to from here.
    /// </summary>
    public ref ImPtrVector<ImDrawList> CmdLists => ref Unsafe.AsRef<ImPtrVector<ImDrawList>>(&Handle->CmdLists);

    /// <summary>
    /// Top-left position of the viewport to render (== top-left of the orthogonal projection matrix to use) (== GetMainViewport()-&gt;Pos for the main viewport, == (0.0) in most single-viewport applications)
    /// </summary>
    public ref System.Numerics.Vector2 DisplayPos => ref Unsafe.AsRef<System.Numerics.Vector2>(&Handle->DisplayPos);

    /// <summary>
    /// Size of the viewport to render (== GetMainViewport()-&gt;Size for the main viewport, == io.DisplaySize in most single-viewport applications)
    /// </summary>
    public ref System.Numerics.Vector2 DisplaySize => ref Unsafe.AsRef<System.Numerics.Vector2>(&Handle->DisplaySize);

    /// <summary>
    /// Amount of pixels for each unit of DisplaySize. Copied from viewport-&gt;FramebufferScale (== io.DisplayFramebufferScale for main viewport). Generally (1,1) on normal display, (2,2) on OSX with Retina display.
    /// </summary>
    public ref System.Numerics.Vector2 FramebufferScale => ref Unsafe.AsRef<System.Numerics.Vector2>(&Handle->FramebufferScale);

    /// <summary>
    /// Viewport carrying the ImDrawData instance, might be of use to the renderer (generally not).
    /// </summary>
    public ImGuiViewportPtr OwnerViewport
    {
        get => Handle->OwnerViewport;
        set => Handle->OwnerViewport = value;
    }

    /// <summary>
    /// List of textures to update. Most of the times the list is shared by all ImDrawData, has only 1 texture and it doesn't need any update. This almost always points to ImGui::GetPlatformIO().Textures[]. May be overriden or set to NULL if you want to manually update textures.
    /// </summary>
    public ImPtrVector<ImTextureData>* Textures
    {
        get => Handle->Textures;
        set => Handle->Textures = value;
    }

    public void Clear()
    {
        ImGuiNative.ImDrawData_Clear(this.Handle);
    }
    /// <summary>
    /// Helper to add an external draw list into an existing ImDrawData.
    /// </summary>
    public void AddDrawList(ImDrawListPtr draw_list)
    {
        ImGuiNative.ImDrawData_AddDrawList(this.Handle, ImDrawListPtr.GetHandle(draw_list));
    }
    /// <summary>
    /// Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
    /// </summary>
    public void DeIndexAllBuffers()
    {
        ImGuiNative.ImDrawData_DeIndexAllBuffers(this.Handle);
    }
    /// <summary>
    /// Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than Dear ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
    /// </summary>
    public void ScaleClipRects(System.Numerics.Vector2 fb_scale)
    {
        ImGuiNative.ImDrawData_ScaleClipRects(this.Handle, fb_scale);
    }
}
