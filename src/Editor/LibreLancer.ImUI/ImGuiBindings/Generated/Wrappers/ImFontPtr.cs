// <auto-generated/>
// ReSharper disable InconsistentNaming
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace ImGuiNET;

public unsafe partial class ImFontPtr
{
    public ImFont* Handle { get; private set; }

    public ImFontPtr (ImFont* handle)
    {
        Handle = handle;
    }

    internal static ImFontPtr Create(ImFont* handle)
    {
        return handle == null ? null : new(handle);
    }

    internal static ImFont* GetHandle(ImFontPtr self)
    {
        return self == null ? null : self.Handle;
    }

    /// <summary>
    /// <para>[Internal] Members: Hot ~12-20 bytes</para>
    /// 4-8   // Cache last bound baked. NEVER USE DIRECTLY. Use GetFontBaked().
    /// </summary>
    public ImFontBakedPtr LastBaked
    {
        get => Handle->LastBaked;
        set => Handle->LastBaked = value;
    }

    /// <summary>
    /// 4-8   // What we have been loaded into.
    /// </summary>
    public ImFontAtlasPtr ContainerAtlas
    {
        get => Handle->ContainerAtlas;
        set => Handle->ContainerAtlas = value;
    }

    /// <summary>
    /// 4     // Font flags.
    /// </summary>
    public ref ImFontFlags Flags => ref Unsafe.AsRef<ImFontFlags>(&Handle->Flags);

    /// <summary>
    /// Current rasterizer density. This is a varying state of the font.
    /// </summary>
    public ref float CurrentRasterizerDensity => ref Unsafe.AsRef<float>(&Handle->CurrentRasterizerDensity);

    /// <summary>
    /// <para>[Internal] Members: Cold ~24-52 bytes</para>
    /// <para>Conceptually Sources[] is the list of font sources merged to create this font.</para>
    /// Unique identifier for the font
    /// </summary>
    public ref uint FontId => ref Unsafe.AsRef<uint>(&Handle->FontId);

    /// <summary>
    /// 4     // in  // Font size passed to AddFont(). Use for old code calling PushFont() expecting to use that size. (use ImGui::GetFontBaked() to get font baked at current bound size).
    /// </summary>
    public ref float LegacySize => ref Unsafe.AsRef<float>(&Handle->LegacySize);

    /// <summary>
    /// 16    // in  // List of sources. Pointers within ContainerAtlas-&gt;Sources[]
    /// </summary>
    public ref ImPtrVector<ImFontConfig> Sources => ref Unsafe.AsRef<ImPtrVector<ImFontConfig>>(&Handle->Sources);

    /// <summary>
    /// 2-4   // out // Character used for ellipsis rendering ('...').
    /// </summary>
    public ref ushort EllipsisChar => ref Unsafe.AsRef<ushort>(&Handle->EllipsisChar);

    /// <summary>
    /// 2-4   // out // Character used if a glyph isn't found (U+FFFD, '?')
    /// </summary>
    public ref ushort FallbackChar => ref Unsafe.AsRef<ushort>(&Handle->FallbackChar);

    /// <summary>
    /// 1 bytes if ImWchar=ImWchar16, 16 bytes if ImWchar==ImWchar32. Store 1-bit for each block of 4K codepoints that has one active glyph. This is mainly used to facilitate iterations across all used codepoints.
    /// </summary>
    public Span<byte> Used8kPagesMap => Handle->Used8kPagesMap;

    /// <summary>
    /// 1     //     // Mark when the "..." glyph needs to be generated.
    /// </summary>
    public bool EllipsisAutoBake
    {
        get => Handle->EllipsisAutoBake;
        set => Handle->EllipsisAutoBake = value;
    }

    /// <summary>
    /// 16    //     // Remapping pairs when using AddRemapChar(), otherwise empty.
    /// </summary>
    public ref ImGuiStorage RemapPairs => ref Unsafe.AsRef<ImGuiStorage>(&Handle->RemapPairs);

    public bool IsGlyphInFont(ushort c)
    {
        return ImGuiNative.ImFont_IsGlyphInFont(this.Handle, c) != 0;
    }
    public bool IsLoaded()
    {
        return ImGuiNative.ImFont_IsLoaded(this.Handle) != 0;
    }
    /// <summary>
    /// Fill ImFontConfig::Name.
    /// </summary>
    public string GetDebugName()
    {
        return Marshal.PtrToStringUTF8((IntPtr)ImGuiNative.ImFont_GetDebugName(this.Handle));
    }
    /// <summary>
    /// <para>[Internal] Don't use!</para>
    /// <para>'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.</para>
    /// <para>'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.</para>
    /// Get or create baked data for given size
    /// </summary>
    public ImFontBakedPtr GetFontBaked(float font_size, float density = -1.0f)
    {
        return ImFontBakedPtr.Create(ImGuiNative.ImFont_GetFontBaked(this.Handle, font_size, density));
    }
    /// <summary>
    /// utf8
    /// </summary>
    public System.Numerics.Vector2 CalcTextSizeA(float size, float max_width, float wrap_width, string text_begin, int? text_end = null)
    {
        byte* __bytes_text_begin = stackalloc byte[128];
        using var __utf8z_text_begin = new UTF8ZHelper(__bytes_text_begin, 128, text_begin);
        return ImGuiNative.ImFont_CalcTextSizeA(this.Handle, size, max_width, wrap_width, __utf8z_text_begin.Pointer, __utf8z_text_begin.GetTextEnd(text_end), null);
    }
    /// <summary>
    /// utf8
    /// </summary>
    public System.Numerics.Vector2 CalcTextSizeA(float size, float max_width, float wrap_width, string text_begin, int? text_end, byte** remaining)
    {
        byte* __bytes_text_begin = stackalloc byte[128];
        using var __utf8z_text_begin = new UTF8ZHelper(__bytes_text_begin, 128, text_begin);
        return ImGuiNative.ImFont_CalcTextSizeA(this.Handle, size, max_width, wrap_width, __utf8z_text_begin.Pointer, __utf8z_text_begin.GetTextEnd(text_end), remaining);
    }
    public string CalcWordWrapPosition(float size, string text, int? text_end, float wrap_width)
    {
        byte* __bytes_text = stackalloc byte[128];
        using var __utf8z_text = new UTF8ZHelper(__bytes_text, 128, text);
        return Marshal.PtrToStringUTF8((IntPtr)ImGuiNative.ImFont_CalcWordWrapPosition(this.Handle, size, __utf8z_text.Pointer, __utf8z_text.GetTextEnd(text_end), wrap_width));
    }
    public void RenderChar(ImDrawListPtr draw_list, float size, System.Numerics.Vector2 pos, uint col, ushort c)
    {
        ImGuiNative.ImFont_RenderChar(this.Handle, ImDrawListPtr.GetHandle(draw_list), size, pos, col, c, null);
    }
    public void RenderChar(ImDrawListPtr draw_list, float size, System.Numerics.Vector2 pos, uint col, ushort c, ref System.Numerics.Vector4 cpu_fine_clip)
    {
        fixed(System.Numerics.Vector4* __cpu_fine_clip_p = &cpu_fine_clip)
        {
            ImGuiNative.ImFont_RenderChar(this.Handle, ImDrawListPtr.GetHandle(draw_list), size, pos, col, c, __cpu_fine_clip_p);
        }
    }
    public void RenderText(ImDrawListPtr draw_list, float size, System.Numerics.Vector2 pos, uint col, System.Numerics.Vector4 clip_rect, string text_begin, int? text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false)
    {
        byte* __bytes_text_begin = stackalloc byte[128];
        using var __utf8z_text_begin = new UTF8ZHelper(__bytes_text_begin, 128, text_begin);
        ImGuiNative.ImFont_RenderText(this.Handle, ImDrawListPtr.GetHandle(draw_list), size, pos, col, clip_rect, __utf8z_text_begin.Pointer, __utf8z_text_begin.GetTextEnd(text_end), wrap_width, cpu_fine_clip ? (byte)1 : (byte)0);
    }
    /// <summary>
    /// [Internal] Don't use!
    /// </summary>
    public void ClearOutputData()
    {
        ImGuiNative.ImFont_ClearOutputData(this.Handle);
    }
    /// <summary>
    /// Makes 'from_codepoint' character points to 'to_codepoint' glyph.
    /// </summary>
    public void AddRemapChar(ushort from_codepoint, ushort to_codepoint)
    {
        ImGuiNative.ImFont_AddRemapChar(this.Handle, from_codepoint, to_codepoint);
    }
    public bool IsGlyphRangeUnused(uint c_begin, uint c_last)
    {
        return ImGuiNative.ImFont_IsGlyphRangeUnused(this.Handle, c_begin, c_last) != 0;
    }
}
