// <auto-generated/>
// ReSharper disable InconsistentNaming
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace ImGuiNET;

public unsafe partial class ImGuiIOPtr
{
    public ImGuiIO* Handle { get; private set; }

    public ImGuiIOPtr (ImGuiIO* handle)
    {
        Handle = handle;
    }

    internal static ImGuiIOPtr Create(ImGuiIO* handle)
    {
        return handle == null ? null : new(handle);
    }

    internal static ImGuiIO* GetHandle(ImGuiIOPtr self)
    {
        return self == null ? null : self.Handle;
    }

    /// <summary>
    /// = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Keyboard/Gamepad navigation options, etc.
    /// </summary>
    public ref ImGuiConfigFlags ConfigFlags => ref Unsafe.AsRef<ImGuiConfigFlags>(&Handle->ConfigFlags);

    /// <summary>
    /// = 0              // See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.
    /// </summary>
    public ref ImGuiBackendFlags BackendFlags => ref Unsafe.AsRef<ImGuiBackendFlags>(&Handle->BackendFlags);

    /// <summary>
    /// &lt;unset&gt;          // Main display size, in pixels (== GetMainViewport()-&gt;Size). May change every frame.
    /// </summary>
    public ref System.Numerics.Vector2 DisplaySize => ref Unsafe.AsRef<System.Numerics.Vector2>(&Handle->DisplaySize);

    /// <summary>
    /// = (1, 1)         // Main display density. For retina display where window coordinates are different from framebuffer coordinates. This will affect font density + will end up in ImDrawData::FramebufferScale.
    /// </summary>
    public ref System.Numerics.Vector2 DisplayFramebufferScale => ref Unsafe.AsRef<System.Numerics.Vector2>(&Handle->DisplayFramebufferScale);

    /// <summary>
    /// = 1.0f/60.0f     // Time elapsed since last frame, in seconds. May change every frame.
    /// </summary>
    public ref float DeltaTime => ref Unsafe.AsRef<float>(&Handle->DeltaTime);

    /// <summary>
    /// = 5.0f           // Minimum time between saving positions/sizes to .ini file, in seconds.
    /// </summary>
    public ref float IniSavingRate => ref Unsafe.AsRef<float>(&Handle->IniSavingRate);

    /// <summary>
    /// = "imgui.ini"    // Path to .ini file (important: default "imgui.ini" is relative to current working dir!). Set NULL to disable automatic .ini loading/saving or if you want to manually call LoadIniSettingsXXX() / SaveIniSettingsXXX() functions.
    /// </summary>
    public byte* IniFilename
    {
        get => Handle->IniFilename;
        set => Handle->IniFilename = value;
    }

    /// <summary>
    /// = "imgui_log.txt"// Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
    /// </summary>
    public byte* LogFilename
    {
        get => Handle->LogFilename;
        set => Handle->LogFilename = value;
    }

    /// <summary>
    /// = NULL           // Store your own data.
    /// </summary>
    public IntPtr UserData
    {
        get => Handle->UserData;
        set => Handle->UserData = value;
    }

    /// <summary>
    /// <para>Font system</para>
    /// &lt;auto&gt;           // Font atlas: load, rasterize and pack one or more fonts into a single texture.
    /// </summary>
    public ImFontAtlasPtr Fonts
    {
        get => Handle->Fonts;
        set => Handle->Fonts = value;
    }

    /// <summary>
    /// = NULL           // Font to use on NewFrame(). Use NULL to uses Fonts-&gt;Fonts[0].
    /// </summary>
    public ImFontPtr FontDefault
    {
        get => Handle->FontDefault;
        set => Handle->FontDefault = value;
    }

    /// <summary>
    /// = false          // [OBSOLETE] Allow user scaling text of individual window with CTRL+Wheel.
    /// </summary>
    public bool FontAllowUserScaling
    {
        get => Handle->FontAllowUserScaling;
        set => Handle->FontAllowUserScaling = value;
    }

    /// <summary>
    /// <para>Keyboard/Gamepad Navigation options</para>
    /// = false          // Swap Activate&lt;&gt;Cancel (A&lt;&gt;B) buttons, matching typical "Nintendo/Japanese style" gamepad layout.
    /// </summary>
    public bool ConfigNavSwapGamepadButtons
    {
        get => Handle->ConfigNavSwapGamepadButtons;
        set => Handle->ConfigNavSwapGamepadButtons = value;
    }

    /// <summary>
    /// = false          // Directional/tabbing navigation teleports the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is difficult. Will update io.MousePos and set io.WantSetMousePos=true.
    /// </summary>
    public bool ConfigNavMoveSetMousePos
    {
        get => Handle->ConfigNavMoveSetMousePos;
        set => Handle->ConfigNavMoveSetMousePos = value;
    }

    /// <summary>
    /// = true           // Sets io.WantCaptureKeyboard when io.NavActive is set.
    /// </summary>
    public bool ConfigNavCaptureKeyboard
    {
        get => Handle->ConfigNavCaptureKeyboard;
        set => Handle->ConfigNavCaptureKeyboard = value;
    }

    /// <summary>
    /// = true           // Pressing Escape can clear focused item + navigation id/highlight. Set to false if you want to always keep highlight on.
    /// </summary>
    public bool ConfigNavEscapeClearFocusItem
    {
        get => Handle->ConfigNavEscapeClearFocusItem;
        set => Handle->ConfigNavEscapeClearFocusItem = value;
    }

    /// <summary>
    /// = false          // Pressing Escape can clear focused window as well (super set of io.ConfigNavEscapeClearFocusItem).
    /// </summary>
    public bool ConfigNavEscapeClearFocusWindow
    {
        get => Handle->ConfigNavEscapeClearFocusWindow;
        set => Handle->ConfigNavEscapeClearFocusWindow = value;
    }

    /// <summary>
    /// = true           // Using directional navigation key makes the cursor visible. Mouse click hides the cursor.
    /// </summary>
    public bool ConfigNavCursorVisibleAuto
    {
        get => Handle->ConfigNavCursorVisibleAuto;
        set => Handle->ConfigNavCursorVisibleAuto = value;
    }

    /// <summary>
    /// = false          // Navigation cursor is always visible.
    /// </summary>
    public bool ConfigNavCursorVisibleAlways
    {
        get => Handle->ConfigNavCursorVisibleAlways;
        set => Handle->ConfigNavCursorVisibleAlways = value;
    }

    /// <summary>
    /// <para>Miscellaneous options</para>
    /// <para>(you can visualize and interact with all options in 'Demo-&gt;Configuration')</para>
    /// = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by backend implementations.
    /// </summary>
    public bool MouseDrawCursor
    {
        get => Handle->MouseDrawCursor;
        set => Handle->MouseDrawCursor = value;
    }

    /// <summary>
    /// = defined(__APPLE__) // Swap Cmd&lt;&gt;Ctrl keys + OS X style text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl.
    /// </summary>
    public bool ConfigMacOSXBehaviors
    {
        get => Handle->ConfigMacOSXBehaviors;
        set => Handle->ConfigMacOSXBehaviors = value;
    }

    /// <summary>
    /// = true           // Enable input queue trickling: some types of events submitted during the same frame (e.g. button down + up) will be spread over multiple frames, improving interactions with low framerates.
    /// </summary>
    public bool ConfigInputTrickleEventQueue
    {
        get => Handle->ConfigInputTrickleEventQueue;
        set => Handle->ConfigInputTrickleEventQueue = value;
    }

    /// <summary>
    /// = true           // Enable blinking cursor (optional as some users consider it to be distracting).
    /// </summary>
    public bool ConfigInputTextCursorBlink
    {
        get => Handle->ConfigInputTextCursorBlink;
        set => Handle->ConfigInputTextCursorBlink = value;
    }

    /// <summary>
    /// = false          // [BETA] Pressing Enter will keep item active and select contents (single-line only).
    /// </summary>
    public bool ConfigInputTextEnterKeepActive
    {
        get => Handle->ConfigInputTextEnterKeepActive;
        set => Handle->ConfigInputTextEnterKeepActive = value;
    }

    /// <summary>
    /// = false          // [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.
    /// </summary>
    public bool ConfigDragClickToInputText
    {
        get => Handle->ConfigDragClickToInputText;
        set => Handle->ConfigDragClickToInputText = value;
    }

    /// <summary>
    /// = true           // Enable resizing of windows from their edges and from the lower-left corner. This requires ImGuiBackendFlags_HasMouseCursors for better mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)
    /// </summary>
    public bool ConfigWindowsResizeFromEdges
    {
        get => Handle->ConfigWindowsResizeFromEdges;
        set => Handle->ConfigWindowsResizeFromEdges = value;
    }

    /// <summary>
    /// = false      // Enable allowing to move windows only when clicking on their title bar. Does not apply to windows without a title bar.
    /// </summary>
    public bool ConfigWindowsMoveFromTitleBarOnly
    {
        get => Handle->ConfigWindowsMoveFromTitleBarOnly;
        set => Handle->ConfigWindowsMoveFromTitleBarOnly = value;
    }

    /// <summary>
    /// = false      // [EXPERIMENTAL] CTRL+C copy the contents of focused window into the clipboard. Experimental because: (1) has known issues with nested Begin/End pairs (2) text output quality varies (3) text output is in submission order rather than spatial order.
    /// </summary>
    public bool ConfigWindowsCopyContentsWithCtrlC
    {
        get => Handle->ConfigWindowsCopyContentsWithCtrlC;
        set => Handle->ConfigWindowsCopyContentsWithCtrlC = value;
    }

    /// <summary>
    /// = true           // Enable scrolling page by page when clicking outside the scrollbar grab. When disabled, always scroll to clicked location. When enabled, Shift+Click scrolls to clicked location.
    /// </summary>
    public bool ConfigScrollbarScrollByPage
    {
        get => Handle->ConfigScrollbarScrollByPage;
        set => Handle->ConfigScrollbarScrollByPage = value;
    }

    /// <summary>
    /// = 60.0f          // Timer (in seconds) to free transient windows/tables memory buffers when unused. Set to -1.0f to disable.
    /// </summary>
    public ref float ConfigMemoryCompactTimer => ref Unsafe.AsRef<float>(&Handle->ConfigMemoryCompactTimer);

    /// <summary>
    /// <para>Inputs Behaviors</para>
    /// <para>(other variables, ones which are expected to be tweaked within UI code, are exposed in ImGuiStyle)</para>
    /// = 0.30f          // Time for a double-click, in seconds.
    /// </summary>
    public ref float MouseDoubleClickTime => ref Unsafe.AsRef<float>(&Handle->MouseDoubleClickTime);

    /// <summary>
    /// = 6.0f           // Distance threshold to stay in to validate a double-click, in pixels.
    /// </summary>
    public ref float MouseDoubleClickMaxDist => ref Unsafe.AsRef<float>(&Handle->MouseDoubleClickMaxDist);

    /// <summary>
    /// = 6.0f           // Distance threshold before considering we are dragging.
    /// </summary>
    public ref float MouseDragThreshold => ref Unsafe.AsRef<float>(&Handle->MouseDragThreshold);

    /// <summary>
    /// = 0.275f         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
    /// </summary>
    public ref float KeyRepeatDelay => ref Unsafe.AsRef<float>(&Handle->KeyRepeatDelay);

    /// <summary>
    /// = 0.050f         // When holding a key/button, rate at which it repeats, in seconds.
    /// </summary>
    public ref float KeyRepeatRate => ref Unsafe.AsRef<float>(&Handle->KeyRepeatRate);

    /// <summary>
    /// <para>Options to configure Error Handling and how we handle recoverable errors [EXPERIMENTAL]</para>
    /// <para>- Error recovery is provided as a way to facilitate:</para>
    /// <para>- Recovery after a programming error (native code or scripting language - the later tends to facilitate iterating on code while running).</para>
    /// <para>- Recovery after running an exception handler or any error processing which may skip code after an error has been detected.</para>
    /// <para>- Error recovery is not perfect nor guaranteed! It is a feature to ease development.</para>
    /// <para>You not are not supposed to rely on it in the course of a normal application run.</para>
    /// <para>- Functions that support error recovery are using IM_ASSERT_USER_ERROR() instead of IM_ASSERT().</para>
    /// <para>- By design, we do NOT allow error recovery to be 100% silent. One of the three options needs to be checked!</para>
    /// <para>- Always ensure that on programmers seats you have at minimum Asserts or Tooltips enabled when making direct imgui API calls!</para>
    /// <para>Otherwise it would severely hinder your ability to catch and correct mistakes!</para>
    /// <para>Read https://github.com/ocornut/imgui/wiki/Error-Handling for details.</para>
    /// <para>- Programmer seats: keep asserts (default), or disable asserts and keep error tooltips (new and nice!)</para>
    /// <para>- Non-programmer seats: maybe disable asserts, but make sure errors are resurfaced (tooltips, visible log entries, use callback etc.)</para>
    /// <para>- Recovery after error/exception: record stack sizes with ErrorRecoveryStoreState(), disable assert, set log callback (to e.g. trigger high-level breakpoint), recover with ErrorRecoveryTryToRecoverState(), restore settings.</para>
    /// = true       // Enable error recovery support. Some errors won't be detected and lead to direct crashes if recovery is disabled.
    /// </summary>
    public bool ConfigErrorRecovery
    {
        get => Handle->ConfigErrorRecovery;
        set => Handle->ConfigErrorRecovery = value;
    }

    /// <summary>
    /// = true       // Enable asserts on recoverable error. By default call IM_ASSERT() when returning from a failing IM_ASSERT_USER_ERROR()
    /// </summary>
    public bool ConfigErrorRecoveryEnableAssert
    {
        get => Handle->ConfigErrorRecoveryEnableAssert;
        set => Handle->ConfigErrorRecoveryEnableAssert = value;
    }

    /// <summary>
    /// = true       // Enable debug log output on recoverable errors.
    /// </summary>
    public bool ConfigErrorRecoveryEnableDebugLog
    {
        get => Handle->ConfigErrorRecoveryEnableDebugLog;
        set => Handle->ConfigErrorRecoveryEnableDebugLog = value;
    }

    /// <summary>
    /// = true       // Enable tooltip on recoverable errors. The tooltip include a way to enable asserts if they were disabled.
    /// </summary>
    public bool ConfigErrorRecoveryEnableTooltip
    {
        get => Handle->ConfigErrorRecoveryEnableTooltip;
        set => Handle->ConfigErrorRecoveryEnableTooltip = value;
    }

    /// <summary>
    /// <para>Option to enable various debug tools showing buttons that will call the IM_DEBUG_BREAK() macro.</para>
    /// <para>- The Item Picker tool will be available regardless of this being enabled, in order to maximize its discoverability.</para>
    /// <para>- Requires a debugger being attached, otherwise IM_DEBUG_BREAK() options will appear to crash your application.</para>
    /// <para>e.g. io.ConfigDebugIsDebuggerPresent = ::IsDebuggerPresent() on Win32, or refer to ImOsIsDebuggerPresent() imgui_test_engine/imgui_te_utils.cpp for a Unix compatible version).</para>
    /// = false          // Enable various tools calling IM_DEBUG_BREAK().
    /// </summary>
    public bool ConfigDebugIsDebuggerPresent
    {
        get => Handle->ConfigDebugIsDebuggerPresent;
        set => Handle->ConfigDebugIsDebuggerPresent = value;
    }

    /// <summary>
    /// <para>Tools to detect code submitting items with conflicting/duplicate IDs</para>
    /// <para>- Code should use PushID()/PopID() in loops, or append "##xx" to same-label identifiers.</para>
    /// <para>- Empty label e.g. Button("") == same ID as parent widget/node. Use Button("##xx") instead!</para>
    /// <para>- See FAQ https://github.com/ocornut/imgui/blob/master/docs/FAQ.md#q-about-the-id-stack-system</para>
    /// = true           // Highlight and show an error message popup when multiple items have conflicting identifiers.
    /// </summary>
    public bool ConfigDebugHighlightIdConflicts
    {
        get => Handle->ConfigDebugHighlightIdConflicts;
        set => Handle->ConfigDebugHighlightIdConflicts = value;
    }

    /// <summary>
    /// =true // Show "Item Picker" button in aforementioned popup.
    /// </summary>
    public bool ConfigDebugHighlightIdConflictsShowItemPicker
    {
        get => Handle->ConfigDebugHighlightIdConflictsShowItemPicker;
        set => Handle->ConfigDebugHighlightIdConflictsShowItemPicker = value;
    }

    /// <summary>
    /// <para>Tools to test correct Begin/End and BeginChild/EndChild behaviors.</para>
    /// <para>- Presently Begin()/End() and BeginChild()/EndChild() needs to ALWAYS be called in tandem, regardless of return value of BeginXXX()</para>
    /// <para>- This is inconsistent with other BeginXXX functions and create confusion for many users.</para>
    /// <para>- We expect to update the API eventually. In the meanwhile we provide tools to facilitate checking user-code behavior.</para>
    /// = false          // First-time calls to Begin()/BeginChild() will return false. NEEDS TO BE SET AT APPLICATION BOOT TIME if you don't want to miss windows.
    /// </summary>
    public bool ConfigDebugBeginReturnValueOnce
    {
        get => Handle->ConfigDebugBeginReturnValueOnce;
        set => Handle->ConfigDebugBeginReturnValueOnce = value;
    }

    /// <summary>
    /// = false          // Some calls to Begin()/BeginChild() will return false. Will cycle through window depths then repeat. Suggested use: add "io.ConfigDebugBeginReturnValue = io.KeyShift" in your main loop then occasionally press SHIFT. Windows should be flickering while running.
    /// </summary>
    public bool ConfigDebugBeginReturnValueLoop
    {
        get => Handle->ConfigDebugBeginReturnValueLoop;
        set => Handle->ConfigDebugBeginReturnValueLoop = value;
    }

    /// <summary>
    /// <para>Option to deactivate io.AddFocusEvent(false) handling.</para>
    /// <para>- May facilitate interactions with a debugger when focus loss leads to clearing inputs data.</para>
    /// <para>- Backends may have other side-effects on focus loss, so this will reduce side-effects but not necessary remove all of them.</para>
    /// = false          // Ignore io.AddFocusEvent(false), consequently not calling io.ClearInputKeys()/io.ClearInputMouse() in input processing.
    /// </summary>
    public bool ConfigDebugIgnoreFocusLoss
    {
        get => Handle->ConfigDebugIgnoreFocusLoss;
        set => Handle->ConfigDebugIgnoreFocusLoss = value;
    }

    /// <summary>
    /// <para>Option to audit .ini data</para>
    /// = false          // Save .ini data with extra comments (particularly helpful for Docking, but makes saving slower)
    /// </summary>
    public bool ConfigDebugIniSettings
    {
        get => Handle->ConfigDebugIniSettings;
        set => Handle->ConfigDebugIniSettings = value;
    }

    /// <summary>
    /// <para>Nowadays those would be stored in ImGuiPlatformIO but we are leaving them here for legacy reasons.</para>
    /// <para>Optional: Platform/Renderer backend name (informational only! will be displayed in About Window) + User data for backend/wrappers to store their own stuff.</para>
    /// = NULL
    /// </summary>
    public byte* BackendPlatformName
    {
        get => Handle->BackendPlatformName;
        set => Handle->BackendPlatformName = value;
    }

    /// <summary>
    /// = NULL
    /// </summary>
    public byte* BackendRendererName
    {
        get => Handle->BackendRendererName;
        set => Handle->BackendRendererName = value;
    }

    /// <summary>
    /// = NULL           // User data for platform backend
    /// </summary>
    public IntPtr BackendPlatformUserData
    {
        get => Handle->BackendPlatformUserData;
        set => Handle->BackendPlatformUserData = value;
    }

    /// <summary>
    /// = NULL           // User data for renderer backend
    /// </summary>
    public IntPtr BackendRendererUserData
    {
        get => Handle->BackendRendererUserData;
        set => Handle->BackendRendererUserData = value;
    }

    /// <summary>
    /// = NULL           // User data for non C++ programming language backend
    /// </summary>
    public IntPtr BackendLanguageUserData
    {
        get => Handle->BackendLanguageUserData;
        set => Handle->BackendLanguageUserData = value;
    }

    /// <summary>
    /// Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main game/application (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).
    /// </summary>
    public bool WantCaptureMouse
    {
        get => Handle->WantCaptureMouse;
        set => Handle->WantCaptureMouse = value;
    }

    /// <summary>
    /// Set when Dear ImGui will use keyboard inputs, in this case do not dispatch them to your main game/application (either way, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).
    /// </summary>
    public bool WantCaptureKeyboard
    {
        get => Handle->WantCaptureKeyboard;
        set => Handle->WantCaptureKeyboard = value;
    }

    /// <summary>
    /// Mobile/console: when set, you may display an on-screen keyboard. This is set by Dear ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
    /// </summary>
    public bool WantTextInput
    {
        get => Handle->WantTextInput;
        set => Handle->WantTextInput = value;
    }

    /// <summary>
    /// MousePos has been altered, backend should reposition mouse on next frame. Rarely used! Set only when io.ConfigNavMoveSetMousePos is enabled.
    /// </summary>
    public bool WantSetMousePos
    {
        get => Handle->WantSetMousePos;
        set => Handle->WantSetMousePos = value;
    }

    /// <summary>
    /// When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. Important: clear io.WantSaveIniSettings yourself after saving!
    /// </summary>
    public bool WantSaveIniSettings
    {
        get => Handle->WantSaveIniSettings;
        set => Handle->WantSaveIniSettings = value;
    }

    /// <summary>
    /// Keyboard/Gamepad navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
    /// </summary>
    public bool NavActive
    {
        get => Handle->NavActive;
        set => Handle->NavActive = value;
    }

    /// <summary>
    /// Keyboard/Gamepad navigation highlight is visible and allowed (will handle ImGuiKey_NavXXX events).
    /// </summary>
    public bool NavVisible
    {
        get => Handle->NavVisible;
        set => Handle->NavVisible = value;
    }

    /// <summary>
    /// Estimate of application framerate (rolling average over 60 frames, based on io.DeltaTime), in frame per second. Solely for convenience. Slow applications may not want to use a moving average or may want to reset underlying buffers occasionally.
    /// </summary>
    public ref float Framerate => ref Unsafe.AsRef<float>(&Handle->Framerate);

    /// <summary>
    /// Vertices output during last call to Render()
    /// </summary>
    public ref int MetricsRenderVertices => ref Unsafe.AsRef<int>(&Handle->MetricsRenderVertices);

    /// <summary>
    /// Indices output during last call to Render() = number of triangles * 3
    /// </summary>
    public ref int MetricsRenderIndices => ref Unsafe.AsRef<int>(&Handle->MetricsRenderIndices);

    /// <summary>
    /// Number of visible windows
    /// </summary>
    public ref int MetricsRenderWindows => ref Unsafe.AsRef<int>(&Handle->MetricsRenderWindows);

    /// <summary>
    /// Number of active windows
    /// </summary>
    public ref int MetricsActiveWindows => ref Unsafe.AsRef<int>(&Handle->MetricsActiveWindows);

    /// <summary>
    /// Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.
    /// </summary>
    public ref System.Numerics.Vector2 MouseDelta => ref Unsafe.AsRef<System.Numerics.Vector2>(&Handle->MouseDelta);

    /// <summary>
    /// Parent UI context (needs to be set explicitly by parent).
    /// </summary>
    public ImGuiContextPtr Ctx
    {
        get => Handle->Ctx;
        set => Handle->Ctx = value;
    }

    /// <summary>
    /// <para>Main Input State</para>
    /// <para>(this block used to be written by backend, since 1.87 it is best to NOT write to those directly, call the AddXXX functions above instead)</para>
    /// <para>(reading from those variables is fair game, as they are extremely unlikely to be moving anywhere)</para>
    /// Mouse position, in pixels. Set to ImVec2(-FLT_MAX, -FLT_MAX) if mouse is unavailable (on another screen, etc.)
    /// </summary>
    public ref System.Numerics.Vector2 MousePos => ref Unsafe.AsRef<System.Numerics.Vector2>(&Handle->MousePos);

    /// <summary>
    /// Mouse buttons: 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5). Dear ImGui mostly uses left and right buttons. Other buttons allow us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
    /// </summary>
    public Span<byte> MouseDown => Handle->MouseDown;

    /// <summary>
    /// Mouse wheel Vertical: 1 unit scrolls about 5 lines text. &gt;0 scrolls Up, &lt;0 scrolls Down. Hold SHIFT to turn vertical scroll into horizontal scroll.
    /// </summary>
    public ref float MouseWheel => ref Unsafe.AsRef<float>(&Handle->MouseWheel);

    /// <summary>
    /// Mouse wheel Horizontal. &gt;0 scrolls Left, &lt;0 scrolls Right. Most users don't have a mouse with a horizontal wheel, may not be filled by all backends.
    /// </summary>
    public ref float MouseWheelH => ref Unsafe.AsRef<float>(&Handle->MouseWheelH);

    /// <summary>
    /// Mouse actual input peripheral (Mouse/TouchScreen/Pen).
    /// </summary>
    public ref ImGuiMouseSource MouseSource => ref Unsafe.AsRef<ImGuiMouseSource>(&Handle->MouseSource);

    /// <summary>
    /// Keyboard modifier down: Control
    /// </summary>
    public bool KeyCtrl
    {
        get => Handle->KeyCtrl;
        set => Handle->KeyCtrl = value;
    }

    /// <summary>
    /// Keyboard modifier down: Shift
    /// </summary>
    public bool KeyShift
    {
        get => Handle->KeyShift;
        set => Handle->KeyShift = value;
    }

    /// <summary>
    /// Keyboard modifier down: Alt
    /// </summary>
    public bool KeyAlt
    {
        get => Handle->KeyAlt;
        set => Handle->KeyAlt = value;
    }

    /// <summary>
    /// Keyboard modifier down: Cmd/Super/Windows
    /// </summary>
    public bool KeySuper
    {
        get => Handle->KeySuper;
        set => Handle->KeySuper = value;
    }

    /// <summary>
    /// <para>Other state maintained from data above + IO function calls</para>
    /// Key mods flags (any of ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Alt/ImGuiMod_Super flags, same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags. Read-only, updated by NewFrame()
    /// </summary>
    public ref int KeyMods => ref Unsafe.AsRef<int>(&Handle->KeyMods);

    /// <summary>
    /// Key state for all known keys. MUST use 'key - ImGuiKey_NamedKey_BEGIN' as index. Use IsKeyXXX() functions to access this.
    /// </summary>
    public Span<ImGuiKeyData> KeysData => Handle->KeysData;

    /// <summary>
    /// Alternative to WantCaptureMouse: (WantCaptureMouse == true &amp;&amp; WantCaptureMouseUnlessPopupClose == false) when a click over void is expected to close a popup.
    /// </summary>
    public bool WantCaptureMouseUnlessPopupClose
    {
        get => Handle->WantCaptureMouseUnlessPopupClose;
        set => Handle->WantCaptureMouseUnlessPopupClose = value;
    }

    /// <summary>
    /// Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)
    /// </summary>
    public ref System.Numerics.Vector2 MousePosPrev => ref Unsafe.AsRef<System.Numerics.Vector2>(&Handle->MousePosPrev);

    /// <summary>
    /// Position at time of clicking
    /// </summary>
    public Span<System.Numerics.Vector2> MouseClickedPos => Handle->MouseClickedPos;

    /// <summary>
    /// Time of last click (used to figure out double-click)
    /// </summary>
    public Span<double> MouseClickedTime => Handle->MouseClickedTime;

    /// <summary>
    /// Mouse button went from !Down to Down (same as MouseClickedCount[x] != 0)
    /// </summary>
    public Span<byte> MouseClicked => Handle->MouseClicked;

    /// <summary>
    /// Has mouse button been double-clicked? (same as MouseClickedCount[x] == 2)
    /// </summary>
    public Span<byte> MouseDoubleClicked => Handle->MouseDoubleClicked;

    /// <summary>
    /// == 0 (not clicked), == 1 (same as MouseClicked[]), == 2 (double-clicked), == 3 (triple-clicked) etc. when going from !Down to Down
    /// </summary>
    public Span<ushort> MouseClickedCount => Handle->MouseClickedCount;

    /// <summary>
    /// Count successive number of clicks. Stays valid after mouse release. Reset after another click is done.
    /// </summary>
    public Span<ushort> MouseClickedLastCount => Handle->MouseClickedLastCount;

    /// <summary>
    /// Mouse button went from Down to !Down
    /// </summary>
    public Span<byte> MouseReleased => Handle->MouseReleased;

    /// <summary>
    /// Time of last released (rarely used! but useful to handle delayed single-click when trying to disambiguate them from double-click).
    /// </summary>
    public Span<double> MouseReleasedTime => Handle->MouseReleasedTime;

    /// <summary>
    /// Track if button was clicked inside a dear imgui window or over void blocked by a popup. We don't request mouse capture from the application if click started outside ImGui bounds.
    /// </summary>
    public Span<byte> MouseDownOwned => Handle->MouseDownOwned;

    /// <summary>
    /// Track if button was clicked inside a dear imgui window.
    /// </summary>
    public Span<byte> MouseDownOwnedUnlessPopupClose => Handle->MouseDownOwnedUnlessPopupClose;

    /// <summary>
    /// On a non-Mac system, holding SHIFT requests WheelY to perform the equivalent of a WheelX event. On a Mac system this is already enforced by the system.
    /// </summary>
    public bool MouseWheelRequestAxisSwap
    {
        get => Handle->MouseWheelRequestAxisSwap;
        set => Handle->MouseWheelRequestAxisSwap = value;
    }

    /// <summary>
    /// (OSX) Set to true when the current click was a Ctrl+click that spawned a simulated right click
    /// </summary>
    public bool MouseCtrlLeftAsRightClick
    {
        get => Handle->MouseCtrlLeftAsRightClick;
        set => Handle->MouseCtrlLeftAsRightClick = value;
    }

    /// <summary>
    /// Duration the mouse button has been down (0.0f == just clicked)
    /// </summary>
    public Span<float> MouseDownDuration => Handle->MouseDownDuration;

    /// <summary>
    /// Previous time the mouse button has been down
    /// </summary>
    public Span<float> MouseDownDurationPrev => Handle->MouseDownDurationPrev;

    /// <summary>
    /// Squared maximum distance of how much mouse has traveled from the clicking point (used for moving thresholds)
    /// </summary>
    public Span<float> MouseDragMaxDistanceSqr => Handle->MouseDragMaxDistanceSqr;

    /// <summary>
    /// Touch/Pen pressure (0.0f to 1.0f, should be &gt;0.0f only when MouseDown[0] == true). Helper storage currently unused by Dear ImGui.
    /// </summary>
    public ref float PenPressure => ref Unsafe.AsRef<float>(&Handle->PenPressure);

    /// <summary>
    /// Only modify via AddFocusEvent()
    /// </summary>
    public bool AppFocusLost
    {
        get => Handle->AppFocusLost;
        set => Handle->AppFocusLost = value;
    }

    /// <summary>
    /// Only modify via SetAppAcceptingEvents()
    /// </summary>
    public bool AppAcceptingEvents
    {
        get => Handle->AppAcceptingEvents;
        set => Handle->AppAcceptingEvents = value;
    }

    /// <summary>
    /// For AddInputCharacterUTF16()
    /// </summary>
    public ref ushort InputQueueSurrogate => ref Unsafe.AsRef<ushort>(&Handle->InputQueueSurrogate);

    /// <summary>
    /// Queue of _characters_ input (obtained by platform backend). Fill using AddInputCharacter() helper.
    /// </summary>
    public ref ImVector<ushort> InputQueueCharacters => ref Unsafe.AsRef<ImVector<ushort>>(&Handle->InputQueueCharacters);

    /// <summary>
    /// <para>Input Functions</para>
    /// Queue a new key down/up event. Key should be "translated" (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)
    /// </summary>
    public void AddKeyEvent(ImGuiKey key, bool down)
    {
        ImGuiNative.ImGuiIO_AddKeyEvent(this.Handle, key, down ? (byte)1 : (byte)0);
    }
    /// <summary>
    /// Queue a new key down/up event for analog values (e.g. ImGuiKey_Gamepad_ values). Dead-zones should be handled by the backend.
    /// </summary>
    public void AddKeyAnalogEvent(ImGuiKey key, bool down, float v)
    {
        ImGuiNative.ImGuiIO_AddKeyAnalogEvent(this.Handle, key, down ? (byte)1 : (byte)0, v);
    }
    /// <summary>
    /// Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)
    /// </summary>
    public void AddMousePosEvent(float x, float y)
    {
        ImGuiNative.ImGuiIO_AddMousePosEvent(this.Handle, x, y);
    }
    /// <summary>
    /// Queue a mouse button change
    /// </summary>
    public void AddMouseButtonEvent(int button, bool down)
    {
        ImGuiNative.ImGuiIO_AddMouseButtonEvent(this.Handle, button, down ? (byte)1 : (byte)0);
    }
    /// <summary>
    /// Queue a mouse wheel update. wheel_y&lt;0: scroll down, wheel_y&gt;0: scroll up, wheel_x&lt;0: scroll right, wheel_x&gt;0: scroll left.
    /// </summary>
    public void AddMouseWheelEvent(float wheel_x, float wheel_y)
    {
        ImGuiNative.ImGuiIO_AddMouseWheelEvent(this.Handle, wheel_x, wheel_y);
    }
    /// <summary>
    /// Queue a mouse source change (Mouse/TouchScreen/Pen)
    /// </summary>
    public void AddMouseSourceEvent(ImGuiMouseSource source)
    {
        ImGuiNative.ImGuiIO_AddMouseSourceEvent(this.Handle, source);
    }
    /// <summary>
    /// Queue a gain/loss of focus for the application (generally based on OS/platform focus of your window)
    /// </summary>
    public void AddFocusEvent(bool focused)
    {
        ImGuiNative.ImGuiIO_AddFocusEvent(this.Handle, focused ? (byte)1 : (byte)0);
    }
    /// <summary>
    /// Queue a new character input
    /// </summary>
    public void AddInputCharacter(uint c)
    {
        ImGuiNative.ImGuiIO_AddInputCharacter(this.Handle, c);
    }
    /// <summary>
    /// Queue a new character input from a UTF-16 character, it can be a surrogate
    /// </summary>
    public void AddInputCharacterUTF16(ushort c)
    {
        ImGuiNative.ImGuiIO_AddInputCharacterUTF16(this.Handle, c);
    }
    /// <summary>
    /// Queue a new characters input from a UTF-8 string
    /// </summary>
    public void AddInputCharactersUTF8(string str)
    {
        byte* __bytes_str = stackalloc byte[128];
        using var __utf8z_str = new UTF8ZHelper(__bytes_str, 128, str);
        ImGuiNative.ImGuiIO_AddInputCharactersUTF8(this.Handle, __utf8z_str.Pointer);
    }
    /// <summary>
    /// [Optional] Specify index for legacy &lt;1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.
    /// </summary>
    public void SetKeyEventNativeData(ImGuiKey key, int native_keycode, int native_scancode, int native_legacy_index = -1)
    {
        ImGuiNative.ImGuiIO_SetKeyEventNativeData(this.Handle, key, native_keycode, native_scancode, native_legacy_index);
    }
    /// <summary>
    /// Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.
    /// </summary>
    public void SetAppAcceptingEvents(bool accepting_events)
    {
        ImGuiNative.ImGuiIO_SetAppAcceptingEvents(this.Handle, accepting_events ? (byte)1 : (byte)0);
    }
    /// <summary>
    /// Clear all incoming events.
    /// </summary>
    public void ClearEventsQueue()
    {
        ImGuiNative.ImGuiIO_ClearEventsQueue(this.Handle);
    }
    /// <summary>
    /// Clear current keyboard/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.
    /// </summary>
    public void ClearInputKeys()
    {
        ImGuiNative.ImGuiIO_ClearInputKeys(this.Handle);
    }
    /// <summary>
    /// Clear current mouse state.
    /// </summary>
    public void ClearInputMouse()
    {
        ImGuiNative.ImGuiIO_ClearInputMouse(this.Handle);
    }
}
