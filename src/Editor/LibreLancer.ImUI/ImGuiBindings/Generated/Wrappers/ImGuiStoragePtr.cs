// <auto-generated/>
// ReSharper disable InconsistentNaming
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace ImGuiNET;

public unsafe partial class ImGuiStoragePtr
{
    public ImGuiStorage* Handle { get; private set; }

    public ImGuiStoragePtr (ImGuiStorage* handle)
    {
        Handle = handle;
    }

    internal static ImGuiStoragePtr Create(ImGuiStorage* handle)
    {
        return handle == null ? null : new(handle);
    }

    internal static ImGuiStorage* GetHandle(ImGuiStoragePtr self)
    {
        return self == null ? null : self.Handle;
    }

    /// <summary>
    /// [Internal]
    /// </summary>
    public ref ImVector<ImGuiStoragePair> Data => ref Unsafe.AsRef<ImVector<ImGuiStoragePair>>(&Handle->Data);

    /// <summary>
    /// <para>- Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)</para>
    /// <para>- Set***() functions find pair, insertion on demand if missing.</para>
    /// - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.
    /// </summary>
    public void Clear()
    {
        ImGuiNative.ImGuiStorage_Clear(this.Handle);
    }
    public int GetInt(uint key, int default_val = 0)
    {
        return ImGuiNative.ImGuiStorage_GetInt(this.Handle, key, default_val);
    }
    public void SetInt(uint key, int val)
    {
        ImGuiNative.ImGuiStorage_SetInt(this.Handle, key, val);
    }
    public bool GetBool(uint key, bool default_val = false)
    {
        return ImGuiNative.ImGuiStorage_GetBool(this.Handle, key, default_val ? (byte)1 : (byte)0) != 0;
    }
    public void SetBool(uint key, bool val)
    {
        ImGuiNative.ImGuiStorage_SetBool(this.Handle, key, val ? (byte)1 : (byte)0);
    }
    public float GetFloat(uint key, float default_val = 0.0f)
    {
        return ImGuiNative.ImGuiStorage_GetFloat(this.Handle, key, default_val);
    }
    public void SetFloat(uint key, float val)
    {
        ImGuiNative.ImGuiStorage_SetFloat(this.Handle, key, val);
    }
    /// <summary>
    /// default_val is NULL
    /// </summary>
    public IntPtr GetVoidPtr(uint key)
    {
        return ImGuiNative.ImGuiStorage_GetVoidPtr(this.Handle, key);
    }
    public void SetVoidPtr(uint key, IntPtr val)
    {
        ImGuiNative.ImGuiStorage_SetVoidPtr(this.Handle, key, val);
    }
    /// <summary>
    /// <para>- Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.</para>
    /// <para>- References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.</para>
    /// <para>- A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&amp;Continue session if you can't modify existing struct)</para>
    /// float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat("var", pvar, 0, 100.0f); some_var += *pvar;
    /// </summary>
    public ref int GetIntRef(uint key, int default_val = 0)
    {
        return ref Unsafe.AsRef<int>((int*)ImGuiNative.ImGuiStorage_GetIntRef(this.Handle, key, default_val));
    }
    public ref bool GetBoolRef(uint key, bool default_val = false)
    {
        return ref Unsafe.AsRef<bool>((byte*)ImGuiNative.ImGuiStorage_GetBoolRef(this.Handle, key, default_val ? (byte)1 : (byte)0));
    }
    public ref float GetFloatRef(uint key, float default_val = 0.0f)
    {
        return ref Unsafe.AsRef<float>((float*)ImGuiNative.ImGuiStorage_GetFloatRef(this.Handle, key, default_val));
    }
    public IntPtr* GetVoidPtrRef(uint key, IntPtr default_val = 0)
    {
        return ImGuiNative.ImGuiStorage_GetVoidPtrRef(this.Handle, key, default_val);
    }
    /// <summary>
    /// Advanced: for quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
    /// </summary>
    public void BuildSortByKey()
    {
        ImGuiNative.ImGuiStorage_BuildSortByKey(this.Handle);
    }
    /// <summary>
    /// Obsolete: use on your own storage if you know only integer are being stored (open/close all tree nodes)
    /// </summary>
    public void SetAllInt(int val)
    {
        ImGuiNative.ImGuiStorage_SetAllInt(this.Handle, val);
    }
}
