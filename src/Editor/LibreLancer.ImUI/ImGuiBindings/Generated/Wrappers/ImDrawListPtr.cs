// <auto-generated/>
// ReSharper disable InconsistentNaming
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace ImGuiNET;

public unsafe partial class ImDrawListPtr
{
    public ImDrawList* Handle { get; private set; }

    public ImDrawListPtr (ImDrawList* handle)
    {
        Handle = handle;
    }

    internal static ImDrawListPtr Create(ImDrawList* handle)
    {
        return handle == null ? null : new(handle);
    }

    internal static ImDrawList* GetHandle(ImDrawListPtr self)
    {
        return self == null ? null : self.Handle;
    }

    /// <summary>
    /// <para>This is what you have to render</para>
    /// Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
    /// </summary>
    public ref ImVector<ImDrawCmd> CmdBuffer => ref Unsafe.AsRef<ImVector<ImDrawCmd>>(&Handle->CmdBuffer);

    /// <summary>
    /// Index buffer. Each command consume ImDrawCmd::ElemCount of those
    /// </summary>
    public ref ImVector<ushort> IdxBuffer => ref Unsafe.AsRef<ImVector<ushort>>(&Handle->IdxBuffer);

    /// <summary>
    /// Vertex buffer.
    /// </summary>
    public ref ImVector<ImDrawVert> VtxBuffer => ref Unsafe.AsRef<ImVector<ImDrawVert>>(&Handle->VtxBuffer);

    /// <summary>
    /// Flags, you may poke into these to adjust anti-aliasing settings per-primitive.
    /// </summary>
    public ref ImDrawListFlags Flags => ref Unsafe.AsRef<ImDrawListFlags>(&Handle->Flags);

    /// <summary>
    /// <para>[Internal, used while building lists]</para>
    /// [Internal] generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.
    /// </summary>
    public ref uint _VtxCurrentIdx => ref Unsafe.AsRef<uint>(&Handle->_VtxCurrentIdx);

    /// <summary>
    /// Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
    /// </summary>
    public ImDrawListSharedDataPtr _Data
    {
        get => Handle->_Data;
        set => Handle->_Data = value;
    }

    /// <summary>
    /// [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector&lt;&gt; operators too much)
    /// </summary>
    public ImDrawVertPtr _VtxWritePtr
    {
        get => Handle->_VtxWritePtr;
        set => Handle->_VtxWritePtr = value;
    }

    /// <summary>
    /// [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector&lt;&gt; operators too much)
    /// </summary>
    public ushort* _IdxWritePtr
    {
        get => Handle->_IdxWritePtr;
        set => Handle->_IdxWritePtr = value;
    }

    /// <summary>
    /// [Internal] current path building
    /// </summary>
    public ref ImVector<System.Numerics.Vector2> _Path => ref Unsafe.AsRef<ImVector<System.Numerics.Vector2>>(&Handle->_Path);

    /// <summary>
    /// [Internal] template of active commands. Fields should match those of CmdBuffer.back().
    /// </summary>
    public ref ImDrawCmdHeader _CmdHeader => ref Unsafe.AsRef<ImDrawCmdHeader>(&Handle->_CmdHeader);

    /// <summary>
    /// [Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)
    /// </summary>
    public ref ImDrawListSplitter _Splitter => ref Unsafe.AsRef<ImDrawListSplitter>(&Handle->_Splitter);

    /// <summary>
    /// [Internal]
    /// </summary>
    public ref ImVector<System.Numerics.Vector4> _ClipRectStack => ref Unsafe.AsRef<ImVector<System.Numerics.Vector4>>(&Handle->_ClipRectStack);

    /// <summary>
    /// [Internal]
    /// </summary>
    public ref ImVector<ImTextureRef> _TextureStack => ref Unsafe.AsRef<ImVector<ImTextureRef>>(&Handle->_TextureStack);

    /// <summary>
    /// [Internal]
    /// </summary>
    public ref ImVector<byte> _CallbacksDataBuf => ref Unsafe.AsRef<ImVector<byte>>(&Handle->_CallbacksDataBuf);

    /// <summary>
    /// [Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content
    /// </summary>
    public ref float _FringeScale => ref Unsafe.AsRef<float>(&Handle->_FringeScale);

    /// <summary>
    /// Pointer to owner window's name for debugging
    /// </summary>
    public byte* _OwnerName
    {
        get => Handle->_OwnerName;
        set => Handle->_OwnerName = value;
    }

    /// <summary>
    /// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
    /// </summary>
    public void PushClipRect(System.Numerics.Vector2 clip_rect_min, System.Numerics.Vector2 clip_rect_max, bool intersect_with_current_clip_rect = false)
    {
        ImGuiNative.ImDrawList_PushClipRect(this.Handle, clip_rect_min, clip_rect_max, intersect_with_current_clip_rect ? (byte)1 : (byte)0);
    }
    public void PushClipRectFullScreen()
    {
        ImGuiNative.ImDrawList_PushClipRectFullScreen(this.Handle);
    }
    public void PopClipRect()
    {
        ImGuiNative.ImDrawList_PopClipRect(this.Handle);
    }
    public void PushTexture(ImTextureRef tex_ref)
    {
        ImGuiNative.ImDrawList_PushTexture(this.Handle, tex_ref);
    }
    public void PopTexture()
    {
        ImGuiNative.ImDrawList_PopTexture(this.Handle);
    }
    public System.Numerics.Vector2 GetClipRectMin()
    {
        return ImGuiNative.ImDrawList_GetClipRectMin(this.Handle);
    }
    public System.Numerics.Vector2 GetClipRectMax()
    {
        return ImGuiNative.ImDrawList_GetClipRectMax(this.Handle);
    }
    /// <summary>
    /// <para>Primitives</para>
    /// <para>- Filled shapes must always use clockwise winding order. The anti-aliasing fringe depends on it. Counter-clockwise shapes will have "inward" anti-aliasing.</para>
    /// <para>- For rectangular primitives, "p_min" and "p_max" represent the upper-left and lower-right corners.</para>
    /// <para>- For circle primitives, use "num_segments == 0" to automatically calculate tessellation (preferred).</para>
    /// <para>In older versions (until Dear ImGui 1.77) the AddCircle functions defaulted to num_segments == 12.</para>
    /// <para>In future versions we will use textures to provide cheaper and higher-quality circles.</para>
    /// Use AddNgon() and AddNgonFilled() functions if you need to guarantee a specific number of sides.
    /// </summary>
    public void AddLine(System.Numerics.Vector2 p1, System.Numerics.Vector2 p2, uint col, float thickness = 1.0f)
    {
        ImGuiNative.ImDrawList_AddLine(this.Handle, p1, p2, col, thickness);
    }
    /// <summary>
    /// a: upper-left, b: lower-right (== upper-left + size)
    /// </summary>
    public void AddRect(System.Numerics.Vector2 p_min, System.Numerics.Vector2 p_max, uint col, float rounding = 0.0f, ImDrawFlags flags = (ImDrawFlags)0, float thickness = 1.0f)
    {
        ImGuiNative.ImDrawList_AddRect(this.Handle, p_min, p_max, col, rounding, flags, thickness);
    }
    /// <summary>
    /// a: upper-left, b: lower-right (== upper-left + size)
    /// </summary>
    public void AddRectFilled(System.Numerics.Vector2 p_min, System.Numerics.Vector2 p_max, uint col, float rounding = 0.0f, ImDrawFlags flags = (ImDrawFlags)0)
    {
        ImGuiNative.ImDrawList_AddRectFilled(this.Handle, p_min, p_max, col, rounding, flags);
    }
    public void AddRectFilledMultiColor(System.Numerics.Vector2 p_min, System.Numerics.Vector2 p_max, uint col_upr_left, uint col_upr_right, uint col_bot_right, uint col_bot_left)
    {
        ImGuiNative.ImDrawList_AddRectFilledMultiColor(this.Handle, p_min, p_max, col_upr_left, col_upr_right, col_bot_right, col_bot_left);
    }
    public void AddQuad(System.Numerics.Vector2 p1, System.Numerics.Vector2 p2, System.Numerics.Vector2 p3, System.Numerics.Vector2 p4, uint col, float thickness = 1.0f)
    {
        ImGuiNative.ImDrawList_AddQuad(this.Handle, p1, p2, p3, p4, col, thickness);
    }
    public void AddQuadFilled(System.Numerics.Vector2 p1, System.Numerics.Vector2 p2, System.Numerics.Vector2 p3, System.Numerics.Vector2 p4, uint col)
    {
        ImGuiNative.ImDrawList_AddQuadFilled(this.Handle, p1, p2, p3, p4, col);
    }
    public void AddTriangle(System.Numerics.Vector2 p1, System.Numerics.Vector2 p2, System.Numerics.Vector2 p3, uint col, float thickness = 1.0f)
    {
        ImGuiNative.ImDrawList_AddTriangle(this.Handle, p1, p2, p3, col, thickness);
    }
    public void AddTriangleFilled(System.Numerics.Vector2 p1, System.Numerics.Vector2 p2, System.Numerics.Vector2 p3, uint col)
    {
        ImGuiNative.ImDrawList_AddTriangleFilled(this.Handle, p1, p2, p3, col);
    }
    public void AddCircle(System.Numerics.Vector2 center, float radius, uint col, int num_segments = 0, float thickness = 1.0f)
    {
        ImGuiNative.ImDrawList_AddCircle(this.Handle, center, radius, col, num_segments, thickness);
    }
    public void AddCircleFilled(System.Numerics.Vector2 center, float radius, uint col, int num_segments = 0)
    {
        ImGuiNative.ImDrawList_AddCircleFilled(this.Handle, center, radius, col, num_segments);
    }
    public void AddNgon(System.Numerics.Vector2 center, float radius, uint col, int num_segments, float thickness = 1.0f)
    {
        ImGuiNative.ImDrawList_AddNgon(this.Handle, center, radius, col, num_segments, thickness);
    }
    public void AddNgonFilled(System.Numerics.Vector2 center, float radius, uint col, int num_segments)
    {
        ImGuiNative.ImDrawList_AddNgonFilled(this.Handle, center, radius, col, num_segments);
    }
    public void AddEllipse(System.Numerics.Vector2 center, System.Numerics.Vector2 radius, uint col, float rot = 0.0f, int num_segments = 0, float thickness = 1.0f)
    {
        ImGuiNative.ImDrawList_AddEllipse(this.Handle, center, radius, col, rot, num_segments, thickness);
    }
    public void AddEllipseFilled(System.Numerics.Vector2 center, System.Numerics.Vector2 radius, uint col, float rot = 0.0f, int num_segments = 0)
    {
        ImGuiNative.ImDrawList_AddEllipseFilled(this.Handle, center, radius, col, rot, num_segments);
    }
    public void AddText(System.Numerics.Vector2 pos, uint col, string text_begin, int? text_end = null)
    {
        byte* __bytes_text_begin = stackalloc byte[128];
        using var __utf8z_text_begin = new UTF8ZHelper(__bytes_text_begin, 128, text_begin);
        ImGuiNative.ImDrawList_AddText(this.Handle, pos, col, __utf8z_text_begin.Pointer, __utf8z_text_begin.GetTextEnd(text_end));
    }
    public void AddText(ImFontPtr font, float font_size, System.Numerics.Vector2 pos, uint col, string text_begin, int? text_end = null, float wrap_width = 0.0f)
    {
        byte* __bytes_text_begin = stackalloc byte[128];
        using var __utf8z_text_begin = new UTF8ZHelper(__bytes_text_begin, 128, text_begin);
        ImGuiNative.ImDrawList_AddTextImFontPtr(this.Handle, ImFontPtr.GetHandle(font), font_size, pos, col, __utf8z_text_begin.Pointer, __utf8z_text_begin.GetTextEnd(text_end), wrap_width, null);
    }
    public void AddText(ImFontPtr font, float font_size, System.Numerics.Vector2 pos, uint col, string text_begin, int? text_end, float wrap_width, ref System.Numerics.Vector4 cpu_fine_clip_rect)
    {
        byte* __bytes_text_begin = stackalloc byte[128];
        using var __utf8z_text_begin = new UTF8ZHelper(__bytes_text_begin, 128, text_begin);
        fixed(System.Numerics.Vector4* __cpu_fine_clip_rect_p = &cpu_fine_clip_rect)
        {
            ImGuiNative.ImDrawList_AddTextImFontPtr(this.Handle, ImFontPtr.GetHandle(font), font_size, pos, col, __utf8z_text_begin.Pointer, __utf8z_text_begin.GetTextEnd(text_end), wrap_width, __cpu_fine_clip_rect_p);
        }
    }
    /// <summary>
    /// Cubic Bezier (4 control points)
    /// </summary>
    public void AddBezierCubic(System.Numerics.Vector2 p1, System.Numerics.Vector2 p2, System.Numerics.Vector2 p3, System.Numerics.Vector2 p4, uint col, float thickness, int num_segments = 0)
    {
        ImGuiNative.ImDrawList_AddBezierCubic(this.Handle, p1, p2, p3, p4, col, thickness, num_segments);
    }
    /// <summary>
    /// Quadratic Bezier (3 control points)
    /// </summary>
    public void AddBezierQuadratic(System.Numerics.Vector2 p1, System.Numerics.Vector2 p2, System.Numerics.Vector2 p3, uint col, float thickness, int num_segments = 0)
    {
        ImGuiNative.ImDrawList_AddBezierQuadratic(this.Handle, p1, p2, p3, col, thickness, num_segments);
    }
    /// <summary>
    /// <para>General polygon</para>
    /// <para>- Only simple polygons are supported by filling functions (no self-intersections, no holes).</para>
    /// - Concave polygon fill is more expensive than convex one: it has O(N^2) complexity. Provided as a convenience for the user but not used by the main library.
    /// </summary>
    public void AddPolyline(ref System.Numerics.Vector2 points, int num_points, uint col, ImDrawFlags flags, float thickness)
    {
        fixed(System.Numerics.Vector2* __points_p = &points)
        {
            ImGuiNative.ImDrawList_AddPolyline(this.Handle, __points_p, num_points, col, flags, thickness);
        }
    }
    public void AddConvexPolyFilled(ref System.Numerics.Vector2 points, int num_points, uint col)
    {
        fixed(System.Numerics.Vector2* __points_p = &points)
        {
            ImGuiNative.ImDrawList_AddConvexPolyFilled(this.Handle, __points_p, num_points, col);
        }
    }
    public void AddConcavePolyFilled(ref System.Numerics.Vector2 points, int num_points, uint col)
    {
        fixed(System.Numerics.Vector2* __points_p = &points)
        {
            ImGuiNative.ImDrawList_AddConcavePolyFilled(this.Handle, __points_p, num_points, col);
        }
    }
    /// <summary>
    /// <para>Image primitives</para>
    /// <para>- Read FAQ to understand what ImTextureID/ImTextureRef are.</para>
    /// <para>- "p_min" and "p_max" represent the upper-left and lower-right corners of the rectangle.</para>
    /// - "uv_min" and "uv_max" represent the normalized texture coordinates to use for those corners. Using (0,0)-&gt;(1,1) texture coordinates will generally display the entire texture.
    /// </summary>
    public void AddImage(ImTextureRef tex_ref, System.Numerics.Vector2 p_min, System.Numerics.Vector2 p_max, System.Numerics.Vector2 uv_min = default, ImOptionalArg<System.Numerics.Vector2> uv_max = default, uint col = 0xFFFFFFFFU)
    {
        ImGuiNative.ImDrawList_AddImage(this.Handle, tex_ref, p_min, p_max, uv_min, uv_max.Get(new System.Numerics.Vector2(1, 1)), col);
    }
    public void AddImageQuad(ImTextureRef tex_ref, System.Numerics.Vector2 p1, System.Numerics.Vector2 p2, System.Numerics.Vector2 p3, System.Numerics.Vector2 p4, System.Numerics.Vector2 uv1 = default, ImOptionalArg<System.Numerics.Vector2> uv2 = default, ImOptionalArg<System.Numerics.Vector2> uv3 = default, ImOptionalArg<System.Numerics.Vector2> uv4 = default, uint col = 0xFFFFFFFFU)
    {
        ImGuiNative.ImDrawList_AddImageQuad(this.Handle, tex_ref, p1, p2, p3, p4, uv1, uv2.Get(new System.Numerics.Vector2(1, 0)), uv3.Get(new System.Numerics.Vector2(1, 1)), uv4.Get(new System.Numerics.Vector2(0, 1)), col);
    }
    public void AddImageRounded(ImTextureRef tex_ref, System.Numerics.Vector2 p_min, System.Numerics.Vector2 p_max, System.Numerics.Vector2 uv_min, System.Numerics.Vector2 uv_max, uint col, float rounding, ImDrawFlags flags = (ImDrawFlags)0)
    {
        ImGuiNative.ImDrawList_AddImageRounded(this.Handle, tex_ref, p_min, p_max, uv_min, uv_max, col, rounding, flags);
    }
    /// <summary>
    /// <para>Stateful path API, add points then finish with PathFillConvex() or PathStroke()</para>
    /// <para>- Important: filled shapes must always use clockwise winding order! The anti-aliasing fringe depends on it. Counter-clockwise shapes will have "inward" anti-aliasing.</para>
    /// so e.g. 'PathArcTo(center, radius, PI * -0.5f, PI)' is ok, whereas 'PathArcTo(center, radius, PI, PI * -0.5f)' won't have correct anti-aliasing when followed by PathFillConvex().
    /// </summary>
    public void PathClear()
    {
        ImGuiNative.ImDrawList_PathClear(this.Handle);
    }
    public void PathLineTo(System.Numerics.Vector2 pos)
    {
        ImGuiNative.ImDrawList_PathLineTo(this.Handle, pos);
    }
    public void PathLineToMergeDuplicate(System.Numerics.Vector2 pos)
    {
        ImGuiNative.ImDrawList_PathLineToMergeDuplicate(this.Handle, pos);
    }
    public void PathFillConvex(uint col)
    {
        ImGuiNative.ImDrawList_PathFillConvex(this.Handle, col);
    }
    public void PathFillConcave(uint col)
    {
        ImGuiNative.ImDrawList_PathFillConcave(this.Handle, col);
    }
    public void PathStroke(uint col, ImDrawFlags flags = (ImDrawFlags)0, float thickness = 1.0f)
    {
        ImGuiNative.ImDrawList_PathStroke(this.Handle, col, flags, thickness);
    }
    public void PathArcTo(System.Numerics.Vector2 center, float radius, float a_min, float a_max, int num_segments = 0)
    {
        ImGuiNative.ImDrawList_PathArcTo(this.Handle, center, radius, a_min, a_max, num_segments);
    }
    /// <summary>
    /// Use precomputed angles for a 12 steps circle
    /// </summary>
    public void PathArcToFast(System.Numerics.Vector2 center, float radius, int a_min_of_12, int a_max_of_12)
    {
        ImGuiNative.ImDrawList_PathArcToFast(this.Handle, center, radius, a_min_of_12, a_max_of_12);
    }
    /// <summary>
    /// Ellipse
    /// </summary>
    public void PathEllipticalArcTo(System.Numerics.Vector2 center, System.Numerics.Vector2 radius, float rot, float a_min, float a_max, int num_segments = 0)
    {
        ImGuiNative.ImDrawList_PathEllipticalArcTo(this.Handle, center, radius, rot, a_min, a_max, num_segments);
    }
    /// <summary>
    /// Cubic Bezier (4 control points)
    /// </summary>
    public void PathBezierCubicCurveTo(System.Numerics.Vector2 p2, System.Numerics.Vector2 p3, System.Numerics.Vector2 p4, int num_segments = 0)
    {
        ImGuiNative.ImDrawList_PathBezierCubicCurveTo(this.Handle, p2, p3, p4, num_segments);
    }
    /// <summary>
    /// Quadratic Bezier (3 control points)
    /// </summary>
    public void PathBezierQuadraticCurveTo(System.Numerics.Vector2 p2, System.Numerics.Vector2 p3, int num_segments = 0)
    {
        ImGuiNative.ImDrawList_PathBezierQuadraticCurveTo(this.Handle, p2, p3, num_segments);
    }
    public void PathRect(System.Numerics.Vector2 rect_min, System.Numerics.Vector2 rect_max, float rounding = 0.0f, ImDrawFlags flags = (ImDrawFlags)0)
    {
        ImGuiNative.ImDrawList_PathRect(this.Handle, rect_min, rect_max, rounding, flags);
    }
    /// <summary>
    /// <para>Advanced: Miscellaneous</para>
    /// This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
    /// </summary>
    public void AddDrawCmd()
    {
        ImGuiNative.ImDrawList_AddDrawCmd(this.Handle);
    }
    /// <summary>
    /// Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.
    /// </summary>
    public ImDrawListPtr CloneOutput()
    {
        return ImDrawListPtr.Create(ImGuiNative.ImDrawList_CloneOutput(this.Handle));
    }
    /// <summary>
    /// <para>Advanced: Channels</para>
    /// <para>- Use to split render into layers. By switching channels to can render out-of-order (e.g. submit FG primitives before BG primitives)</para>
    /// <para>- Use to minimize draw calls (e.g. if going back-and-forth between multiple clipping rectangles, prefer to append into separate channels then merge at the end)</para>
    /// <para>- This API shouldn't have been in ImDrawList in the first place!</para>
    /// <para>Prefer using your own persistent instance of ImDrawListSplitter as you can stack them.</para>
    /// Using the ImDrawList::ChannelsXXXX you cannot stack a split over another.
    /// </summary>
    public void ChannelsSplit(int count)
    {
        ImGuiNative.ImDrawList_ChannelsSplit(this.Handle, count);
    }
    public void ChannelsMerge()
    {
        ImGuiNative.ImDrawList_ChannelsMerge(this.Handle);
    }
    public void ChannelsSetCurrent(int n)
    {
        ImGuiNative.ImDrawList_ChannelsSetCurrent(this.Handle, n);
    }
    /// <summary>
    /// <para>Advanced: Primitives allocations</para>
    /// <para>- We render triangles (three vertices)</para>
    /// - All primitives needs to be reserved via PrimReserve() beforehand.
    /// </summary>
    public void PrimReserve(int idx_count, int vtx_count)
    {
        ImGuiNative.ImDrawList_PrimReserve(this.Handle, idx_count, vtx_count);
    }
    public void PrimUnreserve(int idx_count, int vtx_count)
    {
        ImGuiNative.ImDrawList_PrimUnreserve(this.Handle, idx_count, vtx_count);
    }
    /// <summary>
    /// Axis aligned rectangle (composed of two triangles)
    /// </summary>
    public void PrimRect(System.Numerics.Vector2 a, System.Numerics.Vector2 b, uint col)
    {
        ImGuiNative.ImDrawList_PrimRect(this.Handle, a, b, col);
    }
    public void PrimRectUV(System.Numerics.Vector2 a, System.Numerics.Vector2 b, System.Numerics.Vector2 uv_a, System.Numerics.Vector2 uv_b, uint col)
    {
        ImGuiNative.ImDrawList_PrimRectUV(this.Handle, a, b, uv_a, uv_b, col);
    }
    public void PrimQuadUV(System.Numerics.Vector2 a, System.Numerics.Vector2 b, System.Numerics.Vector2 c, System.Numerics.Vector2 d, System.Numerics.Vector2 uv_a, System.Numerics.Vector2 uv_b, System.Numerics.Vector2 uv_c, System.Numerics.Vector2 uv_d, uint col)
    {
        ImGuiNative.ImDrawList_PrimQuadUV(this.Handle, a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);
    }
    public void PrimWriteVtx(System.Numerics.Vector2 pos, System.Numerics.Vector2 uv, uint col)
    {
        ImGuiNative.ImDrawList_PrimWriteVtx(this.Handle, pos, uv, col);
    }
    public void PrimWriteIdx(ushort idx)
    {
        ImGuiNative.ImDrawList_PrimWriteIdx(this.Handle, idx);
    }
    /// <summary>
    /// Write vertex with unique index
    /// </summary>
    public void PrimVtx(System.Numerics.Vector2 pos, System.Numerics.Vector2 uv, uint col)
    {
        ImGuiNative.ImDrawList_PrimVtx(this.Handle, pos, uv, col);
    }
    /// <summary>
    /// [Internal helpers]
    /// </summary>
    public void _SetDrawListSharedData(ImDrawListSharedDataPtr data)
    {
        ImGuiNative.ImDrawList__SetDrawListSharedData(this.Handle, ImDrawListSharedDataPtr.GetHandle(data));
    }
    public void _ResetForNewFrame()
    {
        ImGuiNative.ImDrawList__ResetForNewFrame(this.Handle);
    }
    public void _ClearFreeMemory()
    {
        ImGuiNative.ImDrawList__ClearFreeMemory(this.Handle);
    }
    public void _PopUnusedDrawCmd()
    {
        ImGuiNative.ImDrawList__PopUnusedDrawCmd(this.Handle);
    }
    public void _TryMergeDrawCmds()
    {
        ImGuiNative.ImDrawList__TryMergeDrawCmds(this.Handle);
    }
    public void _OnChangedClipRect()
    {
        ImGuiNative.ImDrawList__OnChangedClipRect(this.Handle);
    }
    public void _OnChangedTexture()
    {
        ImGuiNative.ImDrawList__OnChangedTexture(this.Handle);
    }
    public void _OnChangedVtxOffset()
    {
        ImGuiNative.ImDrawList__OnChangedVtxOffset(this.Handle);
    }
    public void _SetTexture(ImTextureRef tex_ref)
    {
        ImGuiNative.ImDrawList__SetTexture(this.Handle, tex_ref);
    }
    public int _CalcCircleAutoSegmentCount(float radius)
    {
        return ImGuiNative.ImDrawList__CalcCircleAutoSegmentCount(this.Handle, radius);
    }
    public void _PathArcToFastEx(System.Numerics.Vector2 center, float radius, int a_min_sample, int a_max_sample, int a_step)
    {
        ImGuiNative.ImDrawList__PathArcToFastEx(this.Handle, center, radius, a_min_sample, a_max_sample, a_step);
    }
    public void _PathArcToN(System.Numerics.Vector2 center, float radius, float a_min, float a_max, int num_segments)
    {
        ImGuiNative.ImDrawList__PathArcToN(this.Handle, center, radius, a_min, a_max, num_segments);
    }
}
