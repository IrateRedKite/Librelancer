// <auto-generated/>
// ReSharper disable InconsistentNaming
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace ImGuiNET;

public unsafe partial class ImFontAtlasPtr
{
    public ImFontAtlas* Handle { get; private set; }

    public ImFontAtlasPtr (ImFontAtlas* handle)
    {
        Handle = handle;
    }

    internal static ImFontAtlasPtr Create(ImFontAtlas* handle)
    {
        return handle == null ? null : new(handle);
    }

    internal static ImFontAtlas* GetHandle(ImFontAtlasPtr self)
    {
        return self == null ? null : self.Handle;
    }

    /// <summary>
    /// <para>Input</para>
    /// Build flags (see ImFontAtlasFlags_)
    /// </summary>
    public ref ImFontAtlasFlags Flags => ref Unsafe.AsRef<ImFontAtlasFlags>(&Handle->Flags);

    /// <summary>
    /// Desired texture format (default to ImTextureFormat_RGBA32 but may be changed to ImTextureFormat_Alpha8).
    /// </summary>
    public ref ImTextureFormat TexDesiredFormat => ref Unsafe.AsRef<ImTextureFormat>(&Handle->TexDesiredFormat);

    /// <summary>
    /// FIXME: Should be called "TexPackPadding". Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0 (will also need to set AntiAliasedLinesUseTex = false).
    /// </summary>
    public ref int TexGlyphPadding => ref Unsafe.AsRef<int>(&Handle->TexGlyphPadding);

    /// <summary>
    /// Minimum desired texture width. Must be a power of two. Default to 512.
    /// </summary>
    public ref int TexMinWidth => ref Unsafe.AsRef<int>(&Handle->TexMinWidth);

    /// <summary>
    /// Minimum desired texture height. Must be a power of two. Default to 128.
    /// </summary>
    public ref int TexMinHeight => ref Unsafe.AsRef<int>(&Handle->TexMinHeight);

    /// <summary>
    /// Maximum desired texture width. Must be a power of two. Default to 8192.
    /// </summary>
    public ref int TexMaxWidth => ref Unsafe.AsRef<int>(&Handle->TexMaxWidth);

    /// <summary>
    /// Maximum desired texture height. Must be a power of two. Default to 8192.
    /// </summary>
    public ref int TexMaxHeight => ref Unsafe.AsRef<int>(&Handle->TexMaxHeight);

    /// <summary>
    /// Store your own atlas related user-data (if e.g. you have multiple font atlas).
    /// </summary>
    public IntPtr UserData
    {
        get => Handle->UserData;
        set => Handle->UserData = value;
    }

    /// <summary>
    /// Latest texture identifier == TexData-&gt;GetTexRef().
    /// </summary>
    public ref ImTextureRef TexRef => ref Unsafe.AsRef<ImTextureRef>(&Handle->TexRef);


    /// <summary>
    /// Latest texture.
    /// </summary>
    public ImTextureDataPtr TexData
    {
        get => Handle->TexData;
        set => Handle->TexData = value;
    }

    /// <summary>
    /// <para>[Internal]</para>
    /// Texture list (most often TexList.Size == 1). TexData is always == TexList.back(). DO NOT USE DIRECTLY, USE GetDrawData().Textures[]/GetPlatformIO().Textures[] instead!
    /// </summary>
    public ref ImPtrVector<ImTextureData> TexList => ref Unsafe.AsRef<ImPtrVector<ImTextureData>>(&Handle->TexList);

    /// <summary>
    /// Marked as locked during ImGui::NewFrame()..EndFrame() scope if TexUpdates are not supported. Any attempt to modify the atlas will assert.
    /// </summary>
    public bool Locked
    {
        get => Handle->Locked;
        set => Handle->Locked = value;
    }

    /// <summary>
    /// Copy of (BackendFlags &amp; ImGuiBackendFlags_RendererHasTextures) from supporting context.
    /// </summary>
    public bool RendererHasTextures
    {
        get => Handle->RendererHasTextures;
        set => Handle->RendererHasTextures = value;
    }

    /// <summary>
    /// Set when texture was built matching current font input. Mostly useful for legacy IsBuilt() call.
    /// </summary>
    public bool TexIsBuilt
    {
        get => Handle->TexIsBuilt;
        set => Handle->TexIsBuilt = value;
    }

    /// <summary>
    /// Tell whether our texture data is known to use colors (rather than just alpha channel), in order to help backend select a format or conversion process.
    /// </summary>
    public bool TexPixelsUseColors
    {
        get => Handle->TexPixelsUseColors;
        set => Handle->TexPixelsUseColors = value;
    }

    /// <summary>
    /// = (1.0f/TexData-&gt;TexWidth, 1.0f/TexData-&gt;TexHeight). May change as new texture gets created.
    /// </summary>
    public ref System.Numerics.Vector2 TexUvScale => ref Unsafe.AsRef<System.Numerics.Vector2>(&Handle->TexUvScale);

    /// <summary>
    /// Texture coordinates to a white pixel. May change as new texture gets created.
    /// </summary>
    public ref System.Numerics.Vector2 TexUvWhitePixel => ref Unsafe.AsRef<System.Numerics.Vector2>(&Handle->TexUvWhitePixel);

    /// <summary>
    /// Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
    /// </summary>
    public ref ImPtrVector<ImFont> Fonts => ref Unsafe.AsRef<ImPtrVector<ImFont>>(&Handle->Fonts);

    /// <summary>
    /// Source/configuration data
    /// </summary>
    public ref ImVector<ImFontConfig> Sources => ref Unsafe.AsRef<ImVector<ImFontConfig>>(&Handle->Sources);

    /// <summary>
    /// UVs for baked anti-aliased lines
    /// </summary>
    public Span<System.Numerics.Vector4> TexUvLines => Handle->TexUvLines;

    /// <summary>
    /// Next value to be stored in TexData-&gt;UniqueID
    /// </summary>
    public ref int TexNextUniqueID => ref Unsafe.AsRef<int>(&Handle->TexNextUniqueID);

    /// <summary>
    /// Next value to be stored in ImFont-&gt;FontID
    /// </summary>
    public ref int FontNextUniqueID => ref Unsafe.AsRef<int>(&Handle->FontNextUniqueID);

    /// <summary>
    /// List of users for this atlas. Typically one per Dear ImGui context.
    /// </summary>
    public ref ImVector<IntPtr> DrawListSharedDatas => ref Unsafe.AsRef<ImVector<IntPtr>>(&Handle->DrawListSharedDatas);

    /// <summary>
    /// Opaque interface to our data that doesn't need to be public and may be discarded when rebuilding.
    /// </summary>
    public ImFontAtlasBuilderPtr Builder
    {
        get => Handle->Builder;
        set => Handle->Builder = value;
    }

    /// <summary>
    /// Font loader opaque interface (default to use FreeType when IMGUI_ENABLE_FREETYPE is defined, otherwise default to use stb_truetype). Use SetFontLoader() to change this at runtime.
    /// </summary>
    public ImFontLoaderPtr FontLoader
    {
        get => Handle->FontLoader;
        set => Handle->FontLoader = value;
    }

    /// <summary>
    /// Font loader name (for display e.g. in About box) == FontLoader-&gt;Name
    /// </summary>
    public byte* FontLoaderName
    {
        get => Handle->FontLoaderName;
        set => Handle->FontLoaderName = value;
    }

    /// <summary>
    /// Font backend opaque storage
    /// </summary>
    public IntPtr FontLoaderData
    {
        get => Handle->FontLoaderData;
        set => Handle->FontLoaderData = value;
    }

    /// <summary>
    /// Shared flags (for all fonts) for font loader. THIS IS BUILD IMPLEMENTATION DEPENDENT (e.g. Per-font override is also available in ImFontConfig).
    /// </summary>
    public ref uint FontLoaderFlags => ref Unsafe.AsRef<uint>(&Handle->FontLoaderFlags);

    /// <summary>
    /// Number of contexts using this atlas
    /// </summary>
    public ref int RefCount => ref Unsafe.AsRef<int>(&Handle->RefCount);

    /// <summary>
    /// Context which own the atlas will be in charge of updating and destroying it.
    /// </summary>
    public ImGuiContextPtr OwnerContext
    {
        get => Handle->OwnerContext;
        set => Handle->OwnerContext = value;
    }

    public ImFontPtr AddFont(ImFontConfigPtr font_cfg)
    {
        return ImFontPtr.Create(ImGuiNative.ImFontAtlas_AddFont(this.Handle, ImFontConfigPtr.GetHandle(font_cfg)));
    }
    public ImFontPtr AddFontDefault(ImFontConfigPtr font_cfg = null)
    {
        return ImFontPtr.Create(ImGuiNative.ImFontAtlas_AddFontDefault(this.Handle, ImFontConfigPtr.GetHandle(font_cfg)));
    }
    public ImFontPtr AddFontFromFileTTF(string filename, float size_pixels = 0.0f, ImFontConfigPtr font_cfg = null)
    {
        byte* __bytes_filename = stackalloc byte[128];
        using var __utf8z_filename = new UTF8ZHelper(__bytes_filename, 128, filename);
        return ImFontPtr.Create(ImGuiNative.ImFontAtlas_AddFontFromFileTTF(this.Handle, __utf8z_filename.Pointer, size_pixels, ImFontConfigPtr.GetHandle(font_cfg), null));
    }
    public ImFontPtr AddFontFromFileTTF(string filename, float size_pixels, ImFontConfigPtr font_cfg, ref ushort glyph_ranges)
    {
        byte* __bytes_filename = stackalloc byte[128];
        using var __utf8z_filename = new UTF8ZHelper(__bytes_filename, 128, filename);
        fixed(ushort* __glyph_ranges_p = &glyph_ranges)
        {
            return ImFontPtr.Create(ImGuiNative.ImFontAtlas_AddFontFromFileTTF(this.Handle, __utf8z_filename.Pointer, size_pixels, ImFontConfigPtr.GetHandle(font_cfg), __glyph_ranges_p));
        }
    }
    /// <summary>
    /// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg-&gt;FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.
    /// </summary>
    public ImFontPtr AddFontFromMemoryTTF(IntPtr font_data, int font_data_size, float size_pixels = 0.0f, ImFontConfigPtr font_cfg = null)
    {
        return ImFontPtr.Create(ImGuiNative.ImFontAtlas_AddFontFromMemoryTTF(this.Handle, font_data, font_data_size, size_pixels, ImFontConfigPtr.GetHandle(font_cfg), null));
    }
    /// <summary>
    /// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg-&gt;FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.
    /// </summary>
    public ImFontPtr AddFontFromMemoryTTF(IntPtr font_data, int font_data_size, float size_pixels, ImFontConfigPtr font_cfg, ref ushort glyph_ranges)
    {
        fixed(ushort* __glyph_ranges_p = &glyph_ranges)
        {
            return ImFontPtr.Create(ImGuiNative.ImFontAtlas_AddFontFromMemoryTTF(this.Handle, font_data, font_data_size, size_pixels, ImFontConfigPtr.GetHandle(font_cfg), __glyph_ranges_p));
        }
    }
    /// <summary>
    /// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
    /// </summary>
    public ImFontPtr AddFontFromMemoryCompressedTTF(IntPtr compressed_font_data, int compressed_font_data_size, float size_pixels = 0.0f, ImFontConfigPtr font_cfg = null)
    {
        return ImFontPtr.Create(ImGuiNative.ImFontAtlas_AddFontFromMemoryCompressedTTF(this.Handle, compressed_font_data, compressed_font_data_size, size_pixels, ImFontConfigPtr.GetHandle(font_cfg), null));
    }
    /// <summary>
    /// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
    /// </summary>
    public ImFontPtr AddFontFromMemoryCompressedTTF(IntPtr compressed_font_data, int compressed_font_data_size, float size_pixels, ImFontConfigPtr font_cfg, ref ushort glyph_ranges)
    {
        fixed(ushort* __glyph_ranges_p = &glyph_ranges)
        {
            return ImFontPtr.Create(ImGuiNative.ImFontAtlas_AddFontFromMemoryCompressedTTF(this.Handle, compressed_font_data, compressed_font_data_size, size_pixels, ImFontConfigPtr.GetHandle(font_cfg), __glyph_ranges_p));
        }
    }
    /// <summary>
    /// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
    /// </summary>
    public ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressed_font_data_base85, float size_pixels = 0.0f, ImFontConfigPtr font_cfg = null)
    {
        byte* __bytes_compressed_font_data_base85 = stackalloc byte[128];
        using var __utf8z_compressed_font_data_base85 = new UTF8ZHelper(__bytes_compressed_font_data_base85, 128, compressed_font_data_base85);
        return ImFontPtr.Create(ImGuiNative.ImFontAtlas_AddFontFromMemoryCompressedBase85TTF(this.Handle, __utf8z_compressed_font_data_base85.Pointer, size_pixels, ImFontConfigPtr.GetHandle(font_cfg), null));
    }
    /// <summary>
    /// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
    /// </summary>
    public ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressed_font_data_base85, float size_pixels, ImFontConfigPtr font_cfg, ref ushort glyph_ranges)
    {
        byte* __bytes_compressed_font_data_base85 = stackalloc byte[128];
        using var __utf8z_compressed_font_data_base85 = new UTF8ZHelper(__bytes_compressed_font_data_base85, 128, compressed_font_data_base85);
        fixed(ushort* __glyph_ranges_p = &glyph_ranges)
        {
            return ImFontPtr.Create(ImGuiNative.ImFontAtlas_AddFontFromMemoryCompressedBase85TTF(this.Handle, __utf8z_compressed_font_data_base85.Pointer, size_pixels, ImFontConfigPtr.GetHandle(font_cfg), __glyph_ranges_p));
        }
    }
    public void RemoveFont(ImFontPtr font)
    {
        ImGuiNative.ImFontAtlas_RemoveFont(this.Handle, ImFontPtr.GetHandle(font));
    }
    /// <summary>
    /// Clear everything (input fonts, output glyphs/textures)
    /// </summary>
    public void Clear()
    {
        ImGuiNative.ImFontAtlas_Clear(this.Handle);
    }
    /// <summary>
    /// Compact cached glyphs and texture.
    /// </summary>
    public void CompactCache()
    {
        ImGuiNative.ImFontAtlas_CompactCache(this.Handle);
    }
    /// <summary>
    /// Change font loader at runtime.
    /// </summary>
    public void SetFontLoader(ImFontLoaderPtr font_loader)
    {
        ImGuiNative.ImFontAtlas_SetFontLoader(this.Handle, ImFontLoaderPtr.GetHandle(font_loader));
    }
    /// <summary>
    /// <para>As we are transitioning toward a new font system, we expect to obsolete those soon:</para>
    /// [OBSOLETE] Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.
    /// </summary>
    public void ClearInputData()
    {
        ImGuiNative.ImFontAtlas_ClearInputData(this.Handle);
    }
    /// <summary>
    /// [OBSOLETE] Clear input+output font data (same as ClearInputData() + glyphs storage, UV coordinates).
    /// </summary>
    public void ClearFonts()
    {
        ImGuiNative.ImFontAtlas_ClearFonts(this.Handle);
    }
    /// <summary>
    /// [OBSOLETE] Clear CPU-side copy of the texture data. Saves RAM once the texture has been copied to graphics memory.
    /// </summary>
    public void ClearTexData()
    {
        ImGuiNative.ImFontAtlas_ClearTexData(this.Handle);
    }
    /// <summary>
    /// <para>Since 1.92: specifying glyph ranges is only useful/necessary if your backend doesn't support ImGuiBackendFlags_RendererHasTextures!</para>
    /// Basic Latin, Extended Latin
    /// </summary>
    public ref ushort GetGlyphRangesDefault()
    {
        return ref Unsafe.AsRef<ushort>((ushort*)ImGuiNative.ImFontAtlas_GetGlyphRangesDefault(this.Handle));
    }
    /// <summary>
    /// <para>Register and retrieve custom rectangles</para>
    /// <para>- You can request arbitrary rectangles to be packed into the atlas, for your own purpose.</para>
    /// <para>- Since 1.92.X, packing is done immediately in the function call (previously packing was done during the Build call)</para>
    /// <para>- You can render your pixels into the texture right after calling the AddCustomRect() functions.</para>
    /// <para>- VERY IMPORTANT:</para>
    /// <para>- Texture may be created/resized at any time when calling ImGui or ImFontAtlas functions.</para>
    /// <para>- IT WILL INVALIDATE RECTANGLE DATA SUCH AS UV COORDINATES. Always use latest values from GetCustomRect().</para>
    /// <para>- UV coordinates are associated to the current texture identifier aka 'atlas-&gt;TexRef'. Both TexRef and UV coordinates are typically changed at the same time.</para>
    /// <para>- If you render colored output into your custom rectangles: set 'atlas-&gt;TexPixelsUseColors = true' as this may help some backends decide of preferred texture format.</para>
    /// <para>- Read docs/FONTS.md for more details about using colorful icons.</para>
    /// <para>- Note: this API may be reworked further in order to facilitate supporting e.g. multi-monitor, varying DPI settings.</para>
    /// <para>- (Pre-1.92 names) ------------&gt; (1.92 names)</para>
    /// <para>- GetCustomRectByIndex()   --&gt; Use GetCustomRect()</para>
    /// <para>- CalcCustomRectUV()       --&gt; Use GetCustomRect() and read uv0, uv1 fields.</para>
    /// <para>- AddCustomRectRegular()   --&gt; Renamed to AddCustomRect()</para>
    /// <para>- AddCustomRectFontGlyph() --&gt; Prefer using custom ImFontLoader inside ImFontConfig</para>
    /// <para>- ImFontAtlasCustomRect    --&gt; Renamed to ImFontAtlasRect</para>
    /// Register a rectangle. Return -1 (ImFontAtlasRectId_Invalid) on error.
    /// </summary>
    public int AddCustomRect(int width, int height, ImFontAtlasRectPtr out_r = null)
    {
        return ImGuiNative.ImFontAtlas_AddCustomRect(this.Handle, width, height, ImFontAtlasRectPtr.GetHandle(out_r));
    }
    /// <summary>
    /// Unregister a rectangle. Existing pixels will stay in texture until resized / garbage collected.
    /// </summary>
    public void RemoveCustomRect(int id)
    {
        ImGuiNative.ImFontAtlas_RemoveCustomRect(this.Handle, id);
    }
    /// <summary>
    /// Get rectangle coordinates for current texture. Valid immediately, never store this (read above)!
    /// </summary>
    public bool GetCustomRect(int id, ImFontAtlasRectPtr out_r)
    {
        return ImGuiNative.ImFontAtlas_GetCustomRect(this.Handle, id, ImFontAtlasRectPtr.GetHandle(out_r)) != 0;
    }
}
