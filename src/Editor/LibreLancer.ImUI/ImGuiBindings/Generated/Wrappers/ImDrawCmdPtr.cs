// <auto-generated/>
// ReSharper disable InconsistentNaming
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace ImGuiNET;

public unsafe partial class ImDrawCmdPtr
{
    public ImDrawCmd* Handle { get; private set; }

    public ImDrawCmdPtr (ImDrawCmd* handle)
    {
        Handle = handle;
    }

    internal static ImDrawCmdPtr Create(ImDrawCmd* handle)
    {
        return handle == null ? null : new(handle);
    }

    internal static ImDrawCmd* GetHandle(ImDrawCmdPtr self)
    {
        return self == null ? null : self.Handle;
    }

    /// <summary>
    /// 4*4  // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData-&gt;DisplayPos to get clipping rectangle in "viewport" coordinates
    /// </summary>
    public ref System.Numerics.Vector4 ClipRect => ref Unsafe.AsRef<System.Numerics.Vector4>(&Handle->ClipRect);

    /// <summary>
    /// 16   // Reference to a font/texture atlas (where backend called ImTextureData::SetTexID()) or to a user-provided texture ID (via e.g. ImGui::Image() calls). Both will lead to a ImTextureID value.
    /// </summary>
    public ref ImTextureRef TexRef => ref Unsafe.AsRef<ImTextureRef>(&Handle->TexRef);

    /// <summary>
    /// 4    // Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be &gt;0 to support meshes larger than 64K vertices with 16-bit indices.
    /// </summary>
    public ref uint VtxOffset => ref Unsafe.AsRef<uint>(&Handle->VtxOffset);

    /// <summary>
    /// 4    // Start offset in index buffer.
    /// </summary>
    public ref uint IdxOffset => ref Unsafe.AsRef<uint>(&Handle->IdxOffset);

    /// <summary>
    /// 4    // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
    /// </summary>
    public ref uint ElemCount => ref Unsafe.AsRef<uint>(&Handle->ElemCount);

    /// <summary>
    /// 4-8  // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
    /// </summary>
    public delegate* unmanaged<ImDrawList*, ImDrawCmd*, void> UserCallback
    {
        get => Handle->UserCallback;
        set => Handle->UserCallback = value;
    }

    /// <summary>
    /// 4-8  // Callback user data (when UserCallback != NULL). If called AddCallback() with size == 0, this is a copy of the AddCallback() argument. If called AddCallback() with size &gt; 0, this is pointing to a buffer where data is stored.
    /// </summary>
    public IntPtr UserCallbackData
    {
        get => Handle->UserCallbackData;
        set => Handle->UserCallbackData = value;
    }

    /// <summary>
    /// 4 // Size of callback user data when using storage, otherwise 0.
    /// </summary>
    public ref int UserCallbackDataSize => ref Unsafe.AsRef<int>(&Handle->UserCallbackDataSize);

    /// <summary>
    /// 4 // [Internal] Offset of callback user data when using storage, otherwise -1.
    /// </summary>
    public ref int UserCallbackDataOffset => ref Unsafe.AsRef<int>(&Handle->UserCallbackDataOffset);

    /// <summary>
    /// <para>Since 1.83: returns ImTextureID associated with this draw call. Warning: DO NOT assume this is always same as 'TextureId' (we will change this function for an upcoming feature)</para>
    /// <para>Since 1.92: removed ImDrawCmd::TextureId field, the getter function must be used!</para>
    /// == (TexRef._TexData ? TexRef._TexData-&gt;TexID : TexRef._TexID
    /// </summary>
    public ulong GetTexID()
    {
        return ImGuiNative.ImDrawCmd_GetTexID(this.Handle);
    }
}
