// <auto-generated/>
// ReSharper disable InconsistentNaming
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace ImGuiNET;

public unsafe partial class ImGuiInputTextCallbackDataPtr
{
    public ImGuiInputTextCallbackData* Handle { get; private set; }

    public ImGuiInputTextCallbackDataPtr (ImGuiInputTextCallbackData* handle)
    {
        Handle = handle;
    }

    internal static ImGuiInputTextCallbackDataPtr Create(ImGuiInputTextCallbackData* handle)
    {
        return handle == null ? null : new(handle);
    }

    internal static ImGuiInputTextCallbackData* GetHandle(ImGuiInputTextCallbackDataPtr self)
    {
        return self == null ? null : self.Handle;
    }

    /// <summary>
    /// Parent UI context
    /// </summary>
    public ImGuiContextPtr Ctx
    {
        get => Handle->Ctx;
        set => Handle->Ctx = value;
    }

    /// <summary>
    /// One ImGuiInputTextFlags_Callback*    // Read-only
    /// </summary>
    public ref ImGuiInputTextFlags EventFlag => ref Unsafe.AsRef<ImGuiInputTextFlags>(&Handle->EventFlag);

    /// <summary>
    /// What user passed to InputText()      // Read-only
    /// </summary>
    public ref ImGuiInputTextFlags Flags => ref Unsafe.AsRef<ImGuiInputTextFlags>(&Handle->Flags);

    /// <summary>
    /// What user passed to InputText()      // Read-only
    /// </summary>
    public IntPtr UserData
    {
        get => Handle->UserData;
        set => Handle->UserData = value;
    }

    /// <summary>
    /// <para>Arguments for the different callback events</para>
    /// <para>- During Resize callback, Buf will be same as your input buffer.</para>
    /// <para>- However, during Completion/History/Always callback, Buf always points to our own internal data (it is not the same as your buffer)! Changes to it will be reflected into your own buffer shortly after the callback.</para>
    /// <para>- To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.</para>
    /// <para>- If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 &lt;= BufTextLen &lt; BufSize) and set 'BufDirty'' to true so InputText can update its internal state.</para>
    /// Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;
    /// </summary>
    public ref ushort EventChar => ref Unsafe.AsRef<ushort>(&Handle->EventChar);

    /// <summary>
    /// Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]
    /// </summary>
    public ref ImGuiKey EventKey => ref Unsafe.AsRef<ImGuiKey>(&Handle->EventKey);

    /// <summary>
    /// Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!
    /// </summary>
    public IntPtr Buf
    {
        get => Handle->Buf;
        set => Handle->Buf = value;
    }

    /// <summary>
    /// Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()
    /// </summary>
    public ref int BufTextLen => ref Unsafe.AsRef<int>(&Handle->BufTextLen);

    /// <summary>
    /// Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1
    /// </summary>
    public ref int BufSize => ref Unsafe.AsRef<int>(&Handle->BufSize);

    /// <summary>
    /// Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]
    /// </summary>
    public bool BufDirty
    {
        get => Handle->BufDirty;
        set => Handle->BufDirty = value;
    }

    /// <summary>
    /// // Read-write   // [Completion,History,Always]
    /// </summary>
    public ref int CursorPos => ref Unsafe.AsRef<int>(&Handle->CursorPos);

    /// <summary>
    /// // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)
    /// </summary>
    public ref int SelectionStart => ref Unsafe.AsRef<int>(&Handle->SelectionStart);

    /// <summary>
    /// // Read-write   // [Completion,History,Always]
    /// </summary>
    public ref int SelectionEnd => ref Unsafe.AsRef<int>(&Handle->SelectionEnd);

    public void DeleteChars(int pos, int bytes_count)
    {
        ImGuiNative.ImGuiInputTextCallbackData_DeleteChars(this.Handle, pos, bytes_count);
    }
    public void InsertChars(int pos, string text, int? text_end = null)
    {
        byte* __bytes_text = stackalloc byte[128];
        using var __utf8z_text = new UTF8ZHelper(__bytes_text, 128, text);
        ImGuiNative.ImGuiInputTextCallbackData_InsertChars(this.Handle, pos, __utf8z_text.Pointer, __utf8z_text.GetTextEnd(text_end));
    }
    public void SelectAll()
    {
        ImGuiNative.ImGuiInputTextCallbackData_SelectAll(this.Handle);
    }
    public void ClearSelection()
    {
        ImGuiNative.ImGuiInputTextCallbackData_ClearSelection(this.Handle);
    }
    public bool HasSelection()
    {
        return ImGuiNative.ImGuiInputTextCallbackData_HasSelection(this.Handle) != 0;
    }
}
