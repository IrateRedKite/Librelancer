// <auto-generated/>
// ReSharper disable InconsistentNaming
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace ImGuiNET;

public unsafe partial class ImFontConfigPtr
{
    public ImFontConfig* Handle { get; private set; }

    public ImFontConfigPtr (ImFontConfig* handle)
    {
        Handle = handle;
    }

    internal static ImFontConfigPtr Create(ImFontConfig* handle)
    {
        return handle == null ? null : new(handle);
    }

    internal static ImFontConfig* GetHandle(ImFontConfigPtr self)
    {
        return self == null ? null : self.Handle;
    }

    /// <summary>
    /// <para>Data Source</para>
    /// &lt;auto&gt;   // Name (strictly to ease debugging, hence limited size buffer)
    /// </summary>
    public Span<sbyte> Name => Handle->Name;

    /// <summary>
    /// // TTF/OTF data
    /// </summary>
    public IntPtr FontData
    {
        get => Handle->FontData;
        set => Handle->FontData = value;
    }

    /// <summary>
    /// // TTF/OTF data size
    /// </summary>
    public ref int FontDataSize => ref Unsafe.AsRef<int>(&Handle->FontDataSize);

    /// <summary>
    /// true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
    /// </summary>
    public bool FontDataOwnedByAtlas
    {
        get => Handle->FontDataOwnedByAtlas;
        set => Handle->FontDataOwnedByAtlas = value;
    }

    /// <summary>
    /// <para>Options</para>
    /// false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
    /// </summary>
    public bool MergeMode
    {
        get => Handle->MergeMode;
        set => Handle->MergeMode = value;
    }

    /// <summary>
    /// false    // Align every glyph AdvanceX to pixel boundaries. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
    /// </summary>
    public bool PixelSnapH
    {
        get => Handle->PixelSnapH;
        set => Handle->PixelSnapH = value;
    }

    /// <summary>
    /// true     // Align Scaled GlyphOffset.y to pixel boundaries.
    /// </summary>
    public bool PixelSnapV
    {
        get => Handle->PixelSnapV;
        set => Handle->PixelSnapV = value;
    }

    /// <summary>
    /// 0 (2)    // Rasterize at higher quality for sub-pixel positioning. 0 == auto == 1 or 2 depending on size. Note the difference between 2 and 3 is minimal. You can reduce this to 1 for large glyphs save memory. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.
    /// </summary>
    public ref sbyte OversampleH => ref Unsafe.AsRef<sbyte>(&Handle->OversampleH);

    /// <summary>
    /// 0 (1)    // Rasterize at higher quality for sub-pixel positioning. 0 == auto == 1. This is not really useful as we don't use sub-pixel positions on the Y axis.
    /// </summary>
    public ref sbyte OversampleV => ref Unsafe.AsRef<sbyte>(&Handle->OversampleV);

    /// <summary>
    /// 0        // Explicitly specify Unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.
    /// </summary>
    public ref ushort EllipsisChar => ref Unsafe.AsRef<ushort>(&Handle->EllipsisChar);

    /// <summary>
    /// // Size in pixels for rasterizer (more or less maps to the resulting font height).
    /// </summary>
    public ref float SizePixels => ref Unsafe.AsRef<float>(&Handle->SizePixels);

    /// <summary>
    /// NULL     // *LEGACY* THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE. Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list).
    /// </summary>
    public ushort* GlyphRanges
    {
        get => Handle->GlyphRanges;
        set => Handle->GlyphRanges = value;
    }

    /// <summary>
    /// NULL     // Pointer to a small user-provided list of Unicode ranges (2 value per range, values are inclusive, zero-terminated list). This is very close to GlyphRanges[] but designed to exclude ranges from a font source, when merging fonts with overlapping glyphs. Use "Input Glyphs Overlap Detection Tool" to find about your overlapping ranges.
    /// </summary>
    public ushort* GlyphExcludeRanges
    {
        get => Handle->GlyphExcludeRanges;
        set => Handle->GlyphExcludeRanges = value;
    }

    /// <summary>
    /// <para>ImVec2        GlyphExtraSpacing;      // 0, 0     // (REMOVED AT IT SEEMS LARGELY OBSOLETE. PLEASE REPORT IF YOU WERE USING THIS). Extra spacing (in pixels) between glyphs when rendered: essentially add to glyph-&gt;AdvanceX. Only X axis is supported for now.</para>
    /// 0, 0     // Offset (in pixels) all glyphs from this font input. Absolute value for default size, other sizes will scale this value.
    /// </summary>
    public ref System.Numerics.Vector2 GlyphOffset => ref Unsafe.AsRef<System.Numerics.Vector2>(&Handle->GlyphOffset);

    /// <summary>
    /// 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font. Absolute value for default size, other sizes will scale this value.
    /// </summary>
    public ref float GlyphMinAdvanceX => ref Unsafe.AsRef<float>(&Handle->GlyphMinAdvanceX);

    /// <summary>
    /// FLT_MAX  // Maximum AdvanceX for glyphs
    /// </summary>
    public ref float GlyphMaxAdvanceX => ref Unsafe.AsRef<float>(&Handle->GlyphMaxAdvanceX);

    /// <summary>
    /// 0        // Extra spacing (in pixels) between glyphs. Please contact us if you are using this. // FIXME-NEWATLAS: Intentionally unscaled
    /// </summary>
    public ref float GlyphExtraAdvanceX => ref Unsafe.AsRef<float>(&Handle->GlyphExtraAdvanceX);

    /// <summary>
    /// 0        // Index of font within TTF/OTF file
    /// </summary>
    public ref uint FontNo => ref Unsafe.AsRef<uint>(&Handle->FontNo);

    /// <summary>
    /// 0        // Settings for custom font builder. THIS IS BUILDER IMPLEMENTATION DEPENDENT. Leave as zero if unsure.
    /// </summary>
    public ref uint FontLoaderFlags => ref Unsafe.AsRef<uint>(&Handle->FontLoaderFlags);

    /// <summary>
    /// <para>unsigned int  FontBuilderFlags;       // --       // [Renamed in 1.92] Ue FontLoaderFlags.</para>
    /// 1.0f     // Linearly brighten (&gt;1.0f) or darken (&lt;1.0f) font output. Brightening small fonts may be a good workaround to make them more readable. This is a silly thing we may remove in the future.
    /// </summary>
    public ref float RasterizerMultiply => ref Unsafe.AsRef<float>(&Handle->RasterizerMultiply);

    /// <summary>
    /// 1.0f     // [LEGACY: this only makes sense when ImGuiBackendFlags_RendererHasTextures is not supported] DPI scale multiplier for rasterization. Not altering other font metrics: makes it easy to swap between e.g. a 100% and a 400% fonts for a zooming display, or handle Retina screen. IMPORTANT: If you change this it is expected that you increase/decrease font scale roughly to the inverse of this, otherwise quality may look lowered.
    /// </summary>
    public ref float RasterizerDensity => ref Unsafe.AsRef<float>(&Handle->RasterizerDensity);

    /// <summary>
    /// <para>[Internal]</para>
    /// Font flags (don't use just yet, will be exposed in upcoming 1.92.X updates)
    /// </summary>
    public ref ImFontFlags Flags => ref Unsafe.AsRef<ImFontFlags>(&Handle->Flags);

    /// <summary>
    /// Target font (as we merging fonts, multiple ImFontConfig may target the same font)
    /// </summary>
    public ImFontPtr DstFont
    {
        get => Handle->DstFont;
        set => Handle->DstFont = value;
    }

    /// <summary>
    /// Custom font backend for this source (default source is the one stored in ImFontAtlas)
    /// </summary>
    public ImFontLoaderPtr FontLoader
    {
        get => Handle->FontLoader;
        set => Handle->FontLoader = value;
    }

    /// <summary>
    /// Font loader opaque storage (per font config)
    /// </summary>
    public IntPtr FontLoaderData
    {
        get => Handle->FontLoaderData;
        set => Handle->FontLoaderData = value;
    }

}
