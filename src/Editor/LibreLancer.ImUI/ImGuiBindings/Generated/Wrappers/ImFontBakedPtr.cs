// <auto-generated/>
// ReSharper disable InconsistentNaming
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace ImGuiNET;

public unsafe partial class ImFontBakedPtr
{
    public ImFontBaked* Handle { get; private set; }

    public ImFontBakedPtr (ImFontBaked* handle)
    {
        Handle = handle;
    }

    internal static ImFontBakedPtr Create(ImFontBaked* handle)
    {
        return handle == null ? null : new(handle);
    }

    internal static ImFontBaked* GetHandle(ImFontBakedPtr self)
    {
        return self == null ? null : self.Handle;
    }

    /// <summary>
    /// <para>[Internal] Members: Hot ~20/24 bytes (for CalcTextSize)</para>
    /// 12-16 // out // Sparse. Glyphs-&gt;AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this info, and are often bottleneck in large UI).
    /// </summary>
    public ref ImVector<float> IndexAdvanceX => ref Unsafe.AsRef<ImVector<float>>(&Handle->IndexAdvanceX);

    /// <summary>
    /// 4     // out // FindGlyph(FallbackChar)-&gt;AdvanceX
    /// </summary>
    public ref float FallbackAdvanceX => ref Unsafe.AsRef<float>(&Handle->FallbackAdvanceX);

    /// <summary>
    /// 4     // in  // Height of characters/line, set during loading (doesn't change after loading)
    /// </summary>
    public ref float Size => ref Unsafe.AsRef<float>(&Handle->Size);

    /// <summary>
    /// 4     // in  // Density this is baked at
    /// </summary>
    public ref float RasterizerDensity => ref Unsafe.AsRef<float>(&Handle->RasterizerDensity);

    /// <summary>
    /// <para>[Internal] Members: Hot ~28/36 bytes (for RenderText loop)</para>
    /// 12-16 // out // Sparse. Index glyphs by Unicode code-point.
    /// </summary>
    public ref ImVector<ushort> IndexLookup => ref Unsafe.AsRef<ImVector<ushort>>(&Handle->IndexLookup);

    /// <summary>
    /// 12-16 // out // All glyphs.
    /// </summary>
    public ref ImVector<ImFontGlyph> Glyphs => ref Unsafe.AsRef<ImVector<ImFontGlyph>>(&Handle->Glyphs);

    /// <summary>
    /// 4     // out // Index of FontFallbackChar
    /// </summary>
    public ref int FallbackGlyphIndex => ref Unsafe.AsRef<int>(&Handle->FallbackGlyphIndex);

    /// <summary>
    /// <para>[Internal] Members: Cold</para>
    /// 4+4   // out // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize] (unscaled)
    /// </summary>
    public ref float Ascent => ref Unsafe.AsRef<float>(&Handle->Ascent);

    /// <summary>
    /// <para>[Internal] Members: Cold</para>
    /// 4+4   // out // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize] (unscaled)
    /// </summary>
    public ref float Descent => ref Unsafe.AsRef<float>(&Handle->Descent);

    /// <summary>
    /// 3  // out // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)
    /// </summary>
    public uint MetricsTotalSurface
    {
        get => Handle->MetricsTotalSurface;
    }

    /// <summary>
    /// 0  //     // Queued for destroy
    /// </summary>
    public uint WantDestroy
    {
        get => Handle->WantDestroy;
    }

    /// <summary>
    /// 0  //     //
    /// </summary>
    public uint LockLoadingFallback
    {
        get => Handle->LockLoadingFallback;
    }

    /// <summary>
    /// 4     //     // Record of that time this was bounds
    /// </summary>
    public ref int LastUsedFrame => ref Unsafe.AsRef<int>(&Handle->LastUsedFrame);

    /// <summary>
    /// 4     //
    /// </summary>
    public ref uint BakedId => ref Unsafe.AsRef<uint>(&Handle->BakedId);

    /// <summary>
    /// 4-8   // in  // Parent font
    /// </summary>
    public ImFontPtr ContainerFont
    {
        get => Handle->ContainerFont;
        set => Handle->ContainerFont = value;
    }

    /// <summary>
    /// 4-8   //     // Font loader opaque storage (per baked font * sources): single contiguous buffer allocated by imgui, passed to loader.
    /// </summary>
    public IntPtr FontLoaderDatas
    {
        get => Handle->FontLoaderDatas;
        set => Handle->FontLoaderDatas = value;
    }

    public void ClearOutputData()
    {
        ImGuiNative.ImFontBaked_ClearOutputData(this.Handle);
    }
    /// <summary>
    /// Return U+FFFD glyph if requested glyph doesn't exists.
    /// </summary>
    public ImFontGlyphPtr FindGlyph(ushort c)
    {
        return ImFontGlyphPtr.Create(ImGuiNative.ImFontBaked_FindGlyph(this.Handle, c));
    }
    /// <summary>
    /// Return NULL if glyph doesn't exist
    /// </summary>
    public ImFontGlyphPtr FindGlyphNoFallback(ushort c)
    {
        return ImFontGlyphPtr.Create(ImGuiNative.ImFontBaked_FindGlyphNoFallback(this.Handle, c));
    }
    public float GetCharAdvance(ushort c)
    {
        return ImGuiNative.ImFontBaked_GetCharAdvance(this.Handle, c);
    }
    public bool IsGlyphLoaded(ushort c)
    {
        return ImGuiNative.ImFontBaked_IsGlyphLoaded(this.Handle, c) != 0;
    }
}
