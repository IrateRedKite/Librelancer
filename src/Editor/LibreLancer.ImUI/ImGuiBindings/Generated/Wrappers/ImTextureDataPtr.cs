// <auto-generated/>
// ReSharper disable InconsistentNaming
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace ImGuiNET;

public unsafe partial class ImTextureDataPtr
{
    public ImTextureData* Handle { get; private set; }

    public ImTextureDataPtr (ImTextureData* handle)
    {
        Handle = handle;
    }

    internal static ImTextureDataPtr Create(ImTextureData* handle)
    {
        return handle == null ? null : new(handle);
    }

    internal static ImTextureData* GetHandle(ImTextureDataPtr self)
    {
        return self == null ? null : self.Handle;
    }

    /// <summary>
    /// <para>------------------------------------------ core / backend ---------------------------------------</para>
    /// w    -   // Sequential index to facilitate identifying a texture when debugging/printing. Unique per atlas.
    /// </summary>
    public ref int UniqueID => ref Unsafe.AsRef<int>(&Handle->UniqueID);

    /// <summary>
    /// rw   rw  // ImTextureStatus_OK/_WantCreate/_WantUpdates/_WantDestroy. Always use SetStatus() to modify!
    /// </summary>
    public ref ImTextureStatus Status => ref Unsafe.AsRef<ImTextureStatus>(&Handle->Status);

    /// <summary>
    /// -    rw  // Convenience storage for backend. Some backends may have enough with TexID.
    /// </summary>
    public IntPtr BackendUserData
    {
        get => Handle->BackendUserData;
        set => Handle->BackendUserData = value;
    }

    /// <summary>
    /// r    w   // Backend-specific texture identifier. Always use SetTexID() to modify! The identifier will stored in ImDrawCmd::GetTexID() and passed to backend's RenderDrawData function.
    /// </summary>
    public ref ulong TexID => ref Unsafe.AsRef<ulong>(&Handle->TexID);

    /// <summary>
    /// w    r   // ImTextureFormat_RGBA32 (default) or ImTextureFormat_Alpha8
    /// </summary>
    public ref ImTextureFormat Format => ref Unsafe.AsRef<ImTextureFormat>(&Handle->Format);

    /// <summary>
    /// w    r   // Texture width
    /// </summary>
    public ref int Width => ref Unsafe.AsRef<int>(&Handle->Width);

    /// <summary>
    /// w    r   // Texture height
    /// </summary>
    public ref int Height => ref Unsafe.AsRef<int>(&Handle->Height);

    /// <summary>
    /// w    r   // 4 or 1
    /// </summary>
    public ref int BytesPerPixel => ref Unsafe.AsRef<int>(&Handle->BytesPerPixel);

    /// <summary>
    /// w    r   // Pointer to buffer holding 'Width*Height' pixels and 'Width*Height*BytesPerPixels' bytes.
    /// </summary>
    public byte* Pixels
    {
        get => Handle->Pixels;
        set => Handle->Pixels = value;
    }

    /// <summary>
    /// w    r   // Bounding box encompassing all past and queued Updates[].
    /// </summary>
    public ref ImTextureRect UsedRect => ref Unsafe.AsRef<ImTextureRect>(&Handle->UsedRect);

    /// <summary>
    /// w    r   // Bounding box encompassing all queued Updates[].
    /// </summary>
    public ref ImTextureRect UpdateRect => ref Unsafe.AsRef<ImTextureRect>(&Handle->UpdateRect);

    /// <summary>
    /// w    r   // Array of individual updates.
    /// </summary>
    public ref ImVector<ImTextureRect> Updates => ref Unsafe.AsRef<ImVector<ImTextureRect>>(&Handle->Updates);

    /// <summary>
    /// w    r   // In order to facilitate handling Status==WantDestroy in some backend: this is a count successive frames where the texture was not used. Always &gt;0 when Status==WantDestroy.
    /// </summary>
    public ref int UnusedFrames => ref Unsafe.AsRef<int>(&Handle->UnusedFrames);

    /// <summary>
    /// w    r   // Number of contexts using this texture. Used during backend shutdown.
    /// </summary>
    public ref ushort RefCount => ref Unsafe.AsRef<ushort>(&Handle->RefCount);

    /// <summary>
    /// w    r   // Tell whether our texture data is known to use colors (rather than just white + alpha).
    /// </summary>
    public bool UseColors
    {
        get => Handle->UseColors;
        set => Handle->UseColors = value;
    }

    /// <summary>
    /// rw   -   // [Internal] Queued to set ImTextureStatus_WantDestroy next frame. May still be used in the current frame.
    /// </summary>
    public bool WantDestroyNextFrame
    {
        get => Handle->WantDestroyNextFrame;
        set => Handle->WantDestroyNextFrame = value;
    }

    public void Create(ImTextureFormat format, int w, int h)
    {
        ImGuiNative.ImTextureData_Create(this.Handle, format, w, h);
    }
    public void DestroyPixels()
    {
        ImGuiNative.ImTextureData_DestroyPixels(this.Handle);
    }
    public IntPtr GetPixels()
    {
        return ImGuiNative.ImTextureData_GetPixels(this.Handle);
    }
    public IntPtr GetPixelsAt(int x, int y)
    {
        return ImGuiNative.ImTextureData_GetPixelsAt(this.Handle, x, y);
    }
    public int GetSizeInBytes()
    {
        return ImGuiNative.ImTextureData_GetSizeInBytes(this.Handle);
    }
    public int GetPitch()
    {
        return ImGuiNative.ImTextureData_GetPitch(this.Handle);
    }
    public ImTextureRef GetTexRef()
    {
        return ImGuiNative.ImTextureData_GetTexRef(this.Handle);
    }
    public ulong GetTexID()
    {
        return ImGuiNative.ImTextureData_GetTexID(this.Handle);
    }
    /// <summary>
    /// <para>Called by Renderer backend</para>
    /// Call after creating or destroying the texture. Never modify TexID directly!
    /// </summary>
    public void SetTexID(ulong tex_id)
    {
        ImGuiNative.ImTextureData_SetTexID(this.Handle, tex_id);
    }
    /// <summary>
    /// Call after honoring a request. Never modify Status directly!
    /// </summary>
    public void SetStatus(ImTextureStatus status)
    {
        ImGuiNative.ImTextureData_SetStatus(this.Handle, status);
    }
}
